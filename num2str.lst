   1               		.file	"num2str.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata
  11               	.LC0:
  12 0000 1027      		.word	10000
  13 0002 E803      		.word	1000
  14 0004 6400      		.word	100
  15 0006 0A00      		.word	10
  16 0008 0100      		.word	1
  17               		.text
  18               	.global	usint2decascii
  20               	usint2decascii:
  21               	.LVL0:
  22               	.LFB0:
  23               		.file 1 "num2str.c"
   1:num2str.c     **** /**
   2:num2str.c     ****  * NUM2STR - Functions to handle the conversion of numeric vales to strings.
   3:num2str.c     ****  *
   4:num2str.c     ****  * @author	Neven Boyanov
   5:num2str.c     ****  *
   6:num2str.c     ****  * This is part of the Tinusaur/TinyAVRLib project.
   7:num2str.c     ****  *
   8:num2str.c     ****  * Copyright (c) 2017 Neven Boyanov, The Tinusaur Team. All Rights Reserved.
   9:num2str.c     ****  * Distributed as open source software under MIT License, see LICENSE.txt file.
  10:num2str.c     ****  * Retain in your source code the link http://tinusaur.org to the Tinusaur project.
  11:num2str.c     ****  *
  12:num2str.c     ****  * Source code available at: https://bitbucket.org/tinusaur/tinyavrlib
  13:num2str.c     ****  *
  14:num2str.c     ****  */
  15:num2str.c     **** 
  16:num2str.c     **** // ============================================================================
  17:num2str.c     **** 
  18:num2str.c     **** #include "num2str.h"
  19:num2str.c     **** 
  20:num2str.c     **** // ----------------------------------------------------------------------------
  21:num2str.c     **** 
  22:num2str.c     **** // NOTE: This implementation is borrowed from the LCDDDD library.
  23:num2str.c     **** // Original source code at: https://bitbucket.org/boyanov/avr/src/default/lcdddd/src/lcdddd/lcdddd.
  24:num2str.c     **** 
  25:num2str.c     **** uint8_t usint2decascii(uint16_t num, char *buffer)
  26:num2str.c     **** {
  24               		.loc 1 26 1 view -0
  25               		.cfi_startproc
  26               		.loc 1 26 1 is_stmt 0 view .LVU1
  27 0000 CF93      		push r28
  28               	.LCFI0:
  29               		.cfi_def_cfa_offset 3
  30               		.cfi_offset 28, -2
  31 0002 DF93      		push r29
  32               	.LCFI1:
  33               		.cfi_def_cfa_offset 4
  34               		.cfi_offset 29, -3
  35 0004 CDB7      		in r28,__SP_L__
  36 0006 DEB7      		in r29,__SP_H__
  37               	.LCFI2:
  38               		.cfi_def_cfa_register 28
  39 0008 2A97      		sbiw r28,10
  40               	.LCFI3:
  41               		.cfi_def_cfa_offset 14
  42 000a 0FB6      		in __tmp_reg__,__SREG__
  43 000c F894      		cli
  44 000e DEBF      		out __SP_H__,r29
  45 0010 0FBE      		out __SREG__,__tmp_reg__
  46 0012 CDBF      		out __SP_L__,r28
  47               	/* prologue: function */
  48               	/* frame size = 10 */
  49               	/* stack size = 12 */
  50               	.L__stack_usage = 12
  51 0014 AC01      		movw r20,r24
  27:num2str.c     **** 	const unsigned short powers[] = { 10000u, 1000u, 100u, 10u, 1u }; // The "const unsigned short" co
  52               		.loc 1 27 2 is_stmt 1 view .LVU2
  53               		.loc 1 27 23 is_stmt 0 view .LVU3
  54 0016 8AE0      		ldi r24,lo8(10)
  55               	.LVL1:
  56               		.loc 1 27 23 view .LVU4
  57 0018 E0E0      		ldi r30,lo8(.LC0)
  58 001a F0E0      		ldi r31,hi8(.LC0)
  59 001c DE01      		movw r26,r28
  60 001e 1196      		adiw r26,1
  61               		0:
  62 0020 0190      		ld r0,Z+
  63 0022 0D92      		st X+,r0
  64 0024 8A95      		dec r24
  65 0026 01F4      		brne 0b
  28:num2str.c     **** 	char digit; // "digit" is stored in a char array, so it should be of type char.
  66               		.loc 1 28 2 is_stmt 1 view .LVU5
  29:num2str.c     **** 	uint8_t digits = USINT2DECASCII_MAX_DIGITS - 1;
  67               		.loc 1 29 2 view .LVU6
  68               	.LVL2:
  30:num2str.c     **** 	for (uint8_t pos = 0; pos < 5; pos++) // "pos" is index in array, so should be of type int.
  69               		.loc 1 30 2 view .LVU7
  70               	.LBB2:
  71               		.loc 1 30 7 view .LVU8
  72               		.loc 1 30 7 is_stmt 0 view .LVU9
  73 0028 FE01      		movw r30,r28
  74 002a 3196      		adiw r30,1
  75 002c DB01      		movw r26,r22
  76               		.loc 1 30 15 view .LVU10
  77 002e 20E0      		ldi r18,0
  78               	.LBE2:
  29:num2str.c     **** 	uint8_t digits = USINT2DECASCII_MAX_DIGITS - 1;
  79               		.loc 1 29 10 view .LVU11
  80 0030 84E0      		ldi r24,lo8(4)
  81               	.LVL3:
  82               	.L2:
  83               	.LBB3:
  31:num2str.c     **** 	{
  32:num2str.c     **** 		digit = 0;
  33:num2str.c     **** 		while (num >= powers[pos])
  84               		.loc 1 33 23 view .LVU12
  85 0032 6191      		ld r22,Z+
  86 0034 7191      		ld r23,Z+
  32:num2str.c     **** 		while (num >= powers[pos])
  87               		.loc 1 32 9 view .LVU13
  88 0036 90E0      		ldi r25,0
  89 0038 00C0      		rjmp .L6
  90               	.LVL4:
  91               	.L3:
  34:num2str.c     **** 		{
  35:num2str.c     **** 			digit++;
  92               		.loc 1 35 4 is_stmt 1 view .LVU14
  93               		.loc 1 35 9 is_stmt 0 view .LVU15
  94 003a 9F5F      		subi r25,lo8(-(1))
  95               	.LVL5:
  36:num2str.c     **** 			num -= powers[pos];
  96               		.loc 1 36 4 is_stmt 1 view .LVU16
  97               		.loc 1 36 8 is_stmt 0 view .LVU17
  98 003c 461B      		sub r20,r22
  99 003e 570B      		sbc r21,r23
 100               	.LVL6:
 101               	.L6:
  33:num2str.c     **** 		{
 102               		.loc 1 33 9 view .LVU18
 103 0040 4617      		cp r20,r22
 104 0042 5707      		cpc r21,r23
 105 0044 00F4      		brsh .L3
  37:num2str.c     **** 		}
  38:num2str.c     **** 
  39:num2str.c     **** 		// ---- CHOOSE (1), (2) or (3) ----
  40:num2str.c     **** 
  41:num2str.c     **** 		// CHOICE (1) Fixed width, zero padded result.
  42:num2str.c     **** 		/*
  43:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
  44:num2str.c     **** 		*/
  45:num2str.c     **** 
  46:num2str.c     **** 		// CHOICE (2) Fixed width, zero padded result, digits offset.
  47:num2str.c     **** 		/*
  48:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
  49:num2str.c     **** 		// Note: Determines the offset of the first significant digit.
  50:num2str.c     **** 		if (digits == -1 && digit != 0) digits = pos;
  51:num2str.c     **** 		// Note: Could be used for variable width, not padded, left aligned result.
  52:num2str.c     **** 		*/
  53:num2str.c     **** 
  54:num2str.c     **** 		// CHOICE (3) Fixed width, space (or anything else) padded result, digits offset.
  55:num2str.c     **** 		// Note: Determines the offset of the first significant digit.
  56:num2str.c     **** 		// Note: Could be used for variable width, not padded, left aligned result.
  57:num2str.c     **** 		if (digits == USINT2DECASCII_MAX_DIGITS - 1)
 106               		.loc 1 57 3 is_stmt 1 view .LVU19
 107               		.loc 1 57 6 is_stmt 0 view .LVU20
 108 0046 8430      		cpi r24,lo8(4)
 109 0048 01F4      		brne .L4
  58:num2str.c     **** 		{
  59:num2str.c     **** 			if (digit == 0)
 110               		.loc 1 59 4 is_stmt 1 view .LVU21
 111               		.loc 1 59 7 is_stmt 0 view .LVU22
 112 004a 9111      		cpse r25,__zero_reg__
 113 004c 00C0      		rjmp .L8
  60:num2str.c     **** 			{
  61:num2str.c     **** 				if (pos < USINT2DECASCII_MAX_DIGITS - 1)	// Check position, so single "0" will be handled prope
 114               		.loc 1 61 5 is_stmt 1 view .LVU23
 115               		.loc 1 61 8 is_stmt 0 view .LVU24
 116 004e 2430      		cpi r18,lo8(4)
 117 0050 01F0      		breq .L8
  62:num2str.c     **** 					digit = -16;	// Use: "-16" for space (' '), "-3" for dash/minus ('-'), "0" for zero ('0'), etc
 118               		.loc 1 62 12 view .LVU25
 119 0052 90EF      		ldi r25,lo8(-16)
 120               	.LVL7:
 121               	.L4:
  63:num2str.c     **** 			}
  64:num2str.c     **** 			else
  65:num2str.c     **** 			{
  66:num2str.c     **** 				digits = pos;
  67:num2str.c     **** 			}
  68:num2str.c     **** 		}
  69:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
 122               		.loc 1 69 3 is_stmt 1 discriminator 2 view .LVU26
 123               		.loc 1 69 23 is_stmt 0 discriminator 2 view .LVU27
 124 0054 905D      		subi r25,lo8(-(48))
 125               	.LVL8:
 126               		.loc 1 69 15 discriminator 2 view .LVU28
 127 0056 9D93      		st X+,r25
  30:num2str.c     **** 	{
 128               		.loc 1 30 36 discriminator 2 view .LVU29
 129 0058 2F5F      		subi r18,lo8(-(1))
 130               	.LVL9:
  30:num2str.c     **** 	{
 131               		.loc 1 30 2 discriminator 2 view .LVU30
 132 005a 2530      		cpi r18,lo8(5)
 133 005c 01F4      		brne .L2
 134               	/* epilogue start */
 135               	.LBE3:
  70:num2str.c     **** 
  71:num2str.c     **** 	}
  72:num2str.c     **** 
  73:num2str.c     **** 	// NOTE: The resulting ascii text should not be terminated with '\0' here.
  74:num2str.c     **** 	//       The provided buffer maybe part of a larger text in both directions.
  75:num2str.c     **** 
  76:num2str.c     **** 	return digits;
  77:num2str.c     **** }
 136               		.loc 1 77 1 view .LVU31
 137 005e 2A96      		adiw r28,10
 138 0060 0FB6      		in __tmp_reg__,__SREG__
 139 0062 F894      		cli
 140 0064 DEBF      		out __SP_H__,r29
 141 0066 0FBE      		out __SREG__,__tmp_reg__
 142 0068 CDBF      		out __SP_L__,r28
 143 006a DF91      		pop r29
 144 006c CF91      		pop r28
 145 006e 0895      		ret
 146               	.LVL10:
 147               	.L8:
 148               	.LBB4:
 149               		.loc 1 77 1 view .LVU32
 150 0070 822F      		mov r24,r18
 151               	.LVL11:
 152               		.loc 1 77 1 view .LVU33
 153 0072 00C0      		rjmp .L4
 154               	.LBE4:
 155               		.cfi_endproc
 156               	.LFE0:
 158               	.global	usint2hexascii
 160               	usint2hexascii:
 161               	.LVL12:
 162               	.LFB1:
  78:num2str.c     **** 
  79:num2str.c     **** // ----------------------------------------------------------------------------
  80:num2str.c     **** 
  81:num2str.c     **** uint8_t usint2hexascii(uint16_t num, char *buffer) {
 163               		.loc 1 81 52 is_stmt 1 view -0
 164               		.cfi_startproc
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 169               		.loc 1 81 52 is_stmt 0 view .LVU35
 170 0074 AC01      		movw r20,r24
  82:num2str.c     **** 	for (int8_t pos = USINT2HEXASCII_MAX_DIGITS - 1; pos >= 0 ; pos--) { // "pos" is index in an array
 171               		.loc 1 82 2 is_stmt 1 view .LVU36
 172               	.LBB5:
 173               		.loc 1 82 7 view .LVU37
 174               	.LVL13:
 175               		.loc 1 82 7 is_stmt 0 view .LVU38
 176               	.LBE5:
  81:num2str.c     **** 	for (int8_t pos = USINT2HEXASCII_MAX_DIGITS - 1; pos >= 0 ; pos--) { // "pos" is index in an array
 177               		.loc 1 81 52 view .LVU39
 178 0076 23E0      		ldi r18,lo8(3)
 179 0078 30E0      		ldi r19,0
 180               	.LVL14:
 181               	.L12:
 182               	.LBB8:
 183               	.LBB6:
  83:num2str.c     **** 		char digit = num & 0x000f;
 184               		.loc 1 83 3 is_stmt 1 view .LVU40
 185               		.loc 1 83 8 is_stmt 0 view .LVU41
 186 007a 942F      		mov r25,r20
 187 007c 9F70      		andi r25,lo8(15)
 188               	.LVL15:
  84:num2str.c     **** 		if (digit <= 9) {
 189               		.loc 1 84 3 is_stmt 1 view .LVU42
 190 007e FB01      		movw r30,r22
 191 0080 E20F      		add r30,r18
 192 0082 F31F      		adc r31,r19
 193               		.loc 1 84 6 is_stmt 0 view .LVU43
 194 0084 9A30      		cpi r25,lo8(10)
 195 0086 00F4      		brsh .L10
  85:num2str.c     **** 			buffer[pos] = digit + '0';	// Convert to ASCII
 196               		.loc 1 85 4 is_stmt 1 view .LVU44
 197               		.loc 1 85 24 is_stmt 0 view .LVU45
 198 0088 905D      		subi r25,lo8(-(48))
 199               	.LVL16:
 200               	.L14:
  86:num2str.c     **** 		} else {
  87:num2str.c     **** 			buffer[pos] = digit + 'A' - 10;	// Convert to ASCII
 201               		.loc 1 87 16 view .LVU46
 202 008a 9083      		st Z,r25
  88:num2str.c     **** 		}
  89:num2str.c     **** 		num = num >> 4;
 203               		.loc 1 89 3 is_stmt 1 view .LVU47
 204               		.loc 1 89 7 is_stmt 0 view .LVU48
 205 008c 84E0      		ldi r24,4
 206               		1:
 207 008e 5695      		lsr r21
 208 0090 4795      		ror r20
 209 0092 8A95      		dec r24
 210 0094 01F4      		brne 1b
 211               	.LVL17:
 212               		.loc 1 89 7 view .LVU49
 213               	.LVL18:
 214               		.loc 1 89 7 view .LVU50
 215               	.LBE6:
 216 0096 2150      		subi r18,1
 217 0098 3109      		sbc r19,__zero_reg__
 218 009a 00F4      		brcc .L12
 219               	.LBE8:
  90:num2str.c     **** 	}
  91:num2str.c     **** 	return 4;
 220               		.loc 1 91 2 is_stmt 1 view .LVU51
  92:num2str.c     **** }
 221               		.loc 1 92 1 is_stmt 0 view .LVU52
 222 009c 84E0      		ldi r24,lo8(4)
 223               	/* epilogue start */
 224 009e 0895      		ret
 225               	.LVL19:
 226               	.L10:
 227               	.LBB9:
 228               	.LBB7:
  87:num2str.c     **** 		}
 229               		.loc 1 87 4 is_stmt 1 view .LVU53
  87:num2str.c     **** 		}
 230               		.loc 1 87 30 is_stmt 0 view .LVU54
 231 00a0 995C      		subi r25,lo8(-(55))
 232               	.LVL20:
  87:num2str.c     **** 		}
 233               		.loc 1 87 30 view .LVU55
 234 00a2 00C0      		rjmp .L14
 235               	.LBE7:
 236               	.LBE9:
 237               		.cfi_endproc
 238               	.LFE1:
 240               	.global	usint2binascii
 242               	usint2binascii:
 243               	.LVL21:
 244               	.LFB2:
  93:num2str.c     **** 
  94:num2str.c     **** // ----------------------------------------------------------------------------
  95:num2str.c     **** 
  96:num2str.c     **** // NOTE: The buffer should be always at least MAX_DIGITS in length - the function works with 16-bit
  97:num2str.c     **** 
  98:num2str.c     **** uint8_t usint2binascii(uint16_t num, char *buffer) {
 245               		.loc 1 98 52 is_stmt 1 view -0
 246               		.cfi_startproc
 247               	/* prologue: function */
 248               	/* frame size = 0 */
 249               	/* stack size = 0 */
 250               	.L__stack_usage = 0
 251               		.loc 1 98 52 is_stmt 0 view .LVU57
 252 00a4 FC01      		movw r30,r24
  99:num2str.c     **** 	uint16_t power = 0x8000;	// This is the 1000 0000 0000 0000 binary number.
 253               		.loc 1 99 2 is_stmt 1 view .LVU58
 254               	.LVL22:
 100:num2str.c     **** 	char digit; // "digit" is stored in a char array, so it should be of type char.
 255               		.loc 1 100 2 view .LVU59
 101:num2str.c     **** 	uint8_t digits = USINT2BINASCII_MAX_DIGITS - 1;
 256               		.loc 1 101 2 view .LVU60
 102:num2str.c     **** 	for (uint8_t pos = 0; pos < USINT2BINASCII_MAX_DIGITS; pos++) { // "pos" is index in an array.
 257               		.loc 1 102 2 view .LVU61
 258               	.LBB10:
 259               		.loc 1 102 7 view .LVU62
 260               		.loc 1 102 15 is_stmt 0 view .LVU63
 261 00a6 20E0      		ldi r18,0
 262               	.LBE10:
 101:num2str.c     **** 	uint8_t digits = USINT2BINASCII_MAX_DIGITS - 1;
 263               		.loc 1 101 10 view .LVU64
 264 00a8 8FE0      		ldi r24,lo8(15)
 265               	.LVL23:
  99:num2str.c     **** 	char digit; // "digit" is stored in a char array, so it should be of type char.
 266               		.loc 1 99 11 view .LVU65
 267 00aa 40E0      		ldi r20,0
 268 00ac 50E8      		ldi r21,lo8(-128)
 269               	.LVL24:
 270               	.L17:
 271               	.LBB11:
 103:num2str.c     **** 		digit = 0;
 272               		.loc 1 103 3 is_stmt 1 view .LVU66
 104:num2str.c     **** 		if (num >= power) {
 273               		.loc 1 104 3 view .LVU67
 103:num2str.c     **** 		digit = 0;
 274               		.loc 1 103 9 is_stmt 0 view .LVU68
 275 00ae 90E0      		ldi r25,0
 276               		.loc 1 104 6 view .LVU69
 277 00b0 E417      		cp r30,r20
 278 00b2 F507      		cpc r31,r21
 279 00b4 00F0      		brlo .L16
 105:num2str.c     **** 			digit++;
 280               		.loc 1 105 4 is_stmt 1 view .LVU70
 281               	.LVL25:
 106:num2str.c     **** 			num -= power;
 282               		.loc 1 106 4 view .LVU71
 283               		.loc 1 106 8 is_stmt 0 view .LVU72
 284 00b6 E41B      		sub r30,r20
 285 00b8 F50B      		sbc r31,r21
 286               	.LVL26:
 107:num2str.c     **** 		}
 108:num2str.c     **** 		// Fixed width, space ('0', or anything else) padded result, digits offset.
 109:num2str.c     **** 		// Note: Determines the offset of the first significant digit.
 110:num2str.c     **** 		// Note: Could be used for variable width, not padded, left aligned result.
 111:num2str.c     **** 		if (digits == USINT2BINASCII_MAX_DIGITS - 1) {
 287               		.loc 1 111 3 is_stmt 1 view .LVU73
 288               		.loc 1 111 6 is_stmt 0 view .LVU74
 289 00ba 8F30      		cpi r24,lo8(15)
 290 00bc 01F0      		breq .L19
 291               	.LVL27:
 292               	.L21:
 293               		.loc 1 111 6 view .LVU75
 294 00be 91E0      		ldi r25,lo8(1)
 295               	.LVL28:
 296               	.L16:
 112:num2str.c     **** 			if (digit == 0) {
 113:num2str.c     **** 				if (pos < USINT2BINASCII_MAX_DIGITS - 1) // Check position, so single "0" will be handled prope
 114:num2str.c     **** 					digit = 0; // Use: "-16" for space (' '), "-3" for dash/minus ('-'), "0" for zero ('0'), etc.
 115:num2str.c     **** 			} else {
 116:num2str.c     **** 				digits = pos;
 117:num2str.c     **** 			}
 118:num2str.c     **** 		}
 119:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
 297               		.loc 1 119 3 is_stmt 1 discriminator 2 view .LVU76
 298               		.loc 1 119 23 is_stmt 0 discriminator 2 view .LVU77
 299 00c0 905D      		subi r25,lo8(-(48))
 300               	.LVL29:
 301               		.loc 1 119 15 discriminator 2 view .LVU78
 302 00c2 DB01      		movw r26,r22
 303 00c4 9D93      		st X+,r25
 304 00c6 BD01      		movw r22,r26
 120:num2str.c     **** 		power = power >> 1;
 305               		.loc 1 120 3 is_stmt 1 discriminator 2 view .LVU79
 306               		.loc 1 120 9 is_stmt 0 discriminator 2 view .LVU80
 307 00c8 5695      		lsr r21
 308 00ca 4795      		ror r20
 309               	.LVL30:
 102:num2str.c     **** 		digit = 0;
 310               		.loc 1 102 37 discriminator 2 view .LVU81
 311 00cc 2F5F      		subi r18,lo8(-(1))
 312               	.LVL31:
 102:num2str.c     **** 		digit = 0;
 313               		.loc 1 102 2 discriminator 2 view .LVU82
 314 00ce 2031      		cpi r18,lo8(16)
 315 00d0 01F4      		brne .L17
 316               	/* epilogue start */
 102:num2str.c     **** 		digit = 0;
 317               		.loc 1 102 2 discriminator 2 view .LVU83
 318               	.LBE11:
 121:num2str.c     **** 	}
 122:num2str.c     **** 	// NOTE: The resulting ascii text should not be terminated with '\0' here.
 123:num2str.c     **** 	//       The provided buffer maybe part of a larger text in both directions.
 124:num2str.c     **** 	return digits;
 125:num2str.c     **** }
 319               		.loc 1 125 1 view .LVU84
 320 00d2 0895      		ret
 321               	.LVL32:
 322               	.L19:
 323               	.LBB12:
 111:num2str.c     **** 			if (digit == 0) {
 324               		.loc 1 111 6 view .LVU85
 325 00d4 822F      		mov r24,r18
 326               	.LVL33:
 111:num2str.c     **** 			if (digit == 0) {
 327               		.loc 1 111 6 view .LVU86
 328 00d6 00C0      		rjmp .L21
 329               	.LBE12:
 330               		.cfi_endproc
 331               	.LFE2:
 333               	.Letext0:
 334               		.file 2 "/usr/local/Cellar/avr-gcc/8.2.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 num2str.c
           num2str.s:2      *ABS*:000000000000003e __SP_H__
           num2str.s:3      *ABS*:000000000000003d __SP_L__
           num2str.s:4      *ABS*:000000000000003f __SREG__
           num2str.s:5      *ABS*:0000000000000000 __tmp_reg__
           num2str.s:6      *ABS*:0000000000000001 __zero_reg__
           num2str.s:20     .text:0000000000000000 usint2decascii
           num2str.s:160    .text:0000000000000074 usint2hexascii
           num2str.s:242    .text:00000000000000a4 usint2binascii

UNDEFINED SYMBOLS
__do_copy_data
