   1               		.file	"num2str.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               		.section	.rodata
  11               	.LC0:
  12 0000 1027      		.word	10000
  13 0002 E803      		.word	1000
  14 0004 6400      		.word	100
  15 0006 0A00      		.word	10
  16 0008 0100      		.word	1
  17               		.text
  18               	.global	usint2decascii
  20               	usint2decascii:
  21               	.LVL0:
  22               	.LFB0:
  23               		.file 1 "num2str.c"
   1:num2str.c     **** /**
   2:num2str.c     ****  * NUM2STR - Functions to handle the conversion of numeric vales to strings.
   3:num2str.c     ****  *
   4:num2str.c     ****  * @author	Neven Boyanov
   5:num2str.c     ****  *
   6:num2str.c     ****  * This is part of the Tinusaur/TinyAVRLib project.
   7:num2str.c     ****  *
   8:num2str.c     ****  * Copyright (c) 2017 Neven Boyanov, The Tinusaur Team. All Rights Reserved.
   9:num2str.c     ****  * Distributed as open source software under MIT License, see LICENSE.txt file.
  10:num2str.c     ****  * Retain in your source code the link http://tinusaur.org to the Tinusaur project.
  11:num2str.c     ****  *
  12:num2str.c     ****  * Source code available at: https://bitbucket.org/tinusaur/tinyavrlib
  13:num2str.c     ****  *
  14:num2str.c     ****  */
  15:num2str.c     **** 
  16:num2str.c     **** // ============================================================================
  17:num2str.c     **** 
  18:num2str.c     **** #include "num2str.h"
  19:num2str.c     **** 
  20:num2str.c     **** // ----------------------------------------------------------------------------
  21:num2str.c     **** 
  22:num2str.c     **** // NOTE: This implementation is borrowed from the LCDDDD library.
  23:num2str.c     **** // Original source code at: https://bitbucket.org/boyanov/avr/src/default/lcdddd/src/lcdddd/lcdddd.
  24:num2str.c     **** 
  25:num2str.c     **** uint8_t usint2decascii(uint16_t num, char *buffer)
  26:num2str.c     **** {
  24               		.loc 1 26 1 view -0
  25               		.cfi_startproc
  26               		.loc 1 26 1 is_stmt 0 view .LVU1
  27 0000 CF93      		push r28
  28               	.LCFI0:
  29               		.cfi_def_cfa_offset 3
  30               		.cfi_offset 28, -2
  31 0002 DF93      		push r29
  32               	.LCFI1:
  33               		.cfi_def_cfa_offset 4
  34               		.cfi_offset 29, -3
  35 0004 CDB7      		in r28,__SP_L__
  36 0006 DEB7      		in r29,__SP_H__
  37               	.LCFI2:
  38               		.cfi_def_cfa_register 28
  39 0008 2A97      		sbiw r28,10
  40               	.LCFI3:
  41               		.cfi_def_cfa_offset 14
  42 000a 0FB6      		in __tmp_reg__,__SREG__
  43 000c F894      		cli
  44 000e DEBF      		out __SP_H__,r29
  45 0010 0FBE      		out __SREG__,__tmp_reg__
  46 0012 CDBF      		out __SP_L__,r28
  47               	/* prologue: function */
  48               	/* frame size = 10 */
  49               	/* stack size = 12 */
  50               	.L__stack_usage = 12
  51 0014 AC01      		movw r20,r24
  27:num2str.c     **** 	const unsigned short powers[] = { 10000u, 1000u, 100u, 10u, 1u }; // The "const unsigned short" co
  52               		.loc 1 27 2 is_stmt 1 view .LVU2
  53               		.loc 1 27 23 is_stmt 0 view .LVU3
  54 0016 8AE0      		ldi r24,lo8(10)
  55               	.LVL1:
  56               		.loc 1 27 23 view .LVU4
  57 0018 E0E0      		ldi r30,lo8(.LC0)
  58 001a F0E0      		ldi r31,hi8(.LC0)
  59 001c DE01      		movw r26,r28
  60 001e 1196      		adiw r26,1
  61               		0:
  62 0020 0190      		ld r0,Z+
  63 0022 0D92      		st X+,r0
  64 0024 8A95      		dec r24
  65 0026 01F4      		brne 0b
  28:num2str.c     **** 	char digit; // "digit" is stored in a char array, so it should be of type char.
  66               		.loc 1 28 2 is_stmt 1 view .LVU5
  29:num2str.c     **** 	uint8_t digits = USINT2DECASCII_MAX_DIGITS - 1;
  67               		.loc 1 29 2 view .LVU6
  68               	.LVL2:
  30:num2str.c     **** 	for (uint8_t pos = 0; pos < 5; pos++) // "pos" is index in array, so should be of type int.
  69               		.loc 1 30 2 view .LVU7
  70               	.LBB2:
  71               		.loc 1 30 7 view .LVU8
  72               		.loc 1 30 7 is_stmt 0 view .LVU9
  73 0028 FE01      		movw r30,r28
  74 002a 3196      		adiw r30,1
  75 002c DB01      		movw r26,r22
  76               		.loc 1 30 15 view .LVU10
  77 002e 20E0      		ldi r18,0
  78               	.LBE2:
  29:num2str.c     **** 	uint8_t digits = USINT2DECASCII_MAX_DIGITS - 1;
  79               		.loc 1 29 10 view .LVU11
  80 0030 84E0      		ldi r24,lo8(4)
  81               	.LVL3:
  82               	.L2:
  83               	.LBB3:
  31:num2str.c     **** 	{
  32:num2str.c     **** 		digit = 0;
  33:num2str.c     **** 		while (num >= powers[pos])
  84               		.loc 1 33 23 view .LVU12
  85 0032 6191      		ld r22,Z+
  86 0034 7191      		ld r23,Z+
  32:num2str.c     **** 		while (num >= powers[pos])
  87               		.loc 1 32 9 view .LVU13
  88 0036 90E0      		ldi r25,0
  89 0038 00C0      		rjmp .L6
  90               	.LVL4:
  91               	.L3:
  34:num2str.c     **** 		{
  35:num2str.c     **** 			digit++;
  92               		.loc 1 35 4 is_stmt 1 view .LVU14
  93               		.loc 1 35 9 is_stmt 0 view .LVU15
  94 003a 9F5F      		subi r25,lo8(-(1))
  95               	.LVL5:
  36:num2str.c     **** 			num -= powers[pos];
  96               		.loc 1 36 4 is_stmt 1 view .LVU16
  97               		.loc 1 36 8 is_stmt 0 view .LVU17
  98 003c 461B      		sub r20,r22
  99 003e 570B      		sbc r21,r23
 100               	.LVL6:
 101               	.L6:
  33:num2str.c     **** 		{
 102               		.loc 1 33 9 view .LVU18
 103 0040 4617      		cp r20,r22
 104 0042 5707      		cpc r21,r23
 105 0044 00F4      		brsh .L3
  37:num2str.c     **** 		}
  38:num2str.c     **** 
  39:num2str.c     **** 		// ---- CHOOSE (1), (2) or (3) ----
  40:num2str.c     **** 
  41:num2str.c     **** 		// CHOICE (1) Fixed width, zero padded result.
  42:num2str.c     **** 		/*
  43:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
  44:num2str.c     **** 		*/
  45:num2str.c     **** 
  46:num2str.c     **** 		// CHOICE (2) Fixed width, zero padded result, digits offset.
  47:num2str.c     **** 		/*
  48:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
  49:num2str.c     **** 		// Note: Determines the offset of the first significant digit.
  50:num2str.c     **** 		if (digits == -1 && digit != 0) digits = pos;
  51:num2str.c     **** 		// Note: Could be used for variable width, not padded, left aligned result.
  52:num2str.c     **** 		*/
  53:num2str.c     **** 
  54:num2str.c     **** 		// CHOICE (3) Fixed width, space (or anything else) padded result, digits offset.
  55:num2str.c     **** 		// Note: Determines the offset of the first significant digit.
  56:num2str.c     **** 		// Note: Could be used for variable width, not padded, left aligned result.
  57:num2str.c     **** 		if (digits == USINT2DECASCII_MAX_DIGITS - 1)
 106               		.loc 1 57 3 is_stmt 1 view .LVU19
 107               		.loc 1 57 6 is_stmt 0 view .LVU20
 108 0046 8430      		cpi r24,lo8(4)
 109 0048 01F4      		brne .L4
  58:num2str.c     **** 		{
  59:num2str.c     **** 			if (digit == 0)
 110               		.loc 1 59 4 is_stmt 1 view .LVU21
 111               		.loc 1 59 7 is_stmt 0 view .LVU22
 112 004a 9111      		cpse r25,__zero_reg__
 113 004c 00C0      		rjmp .L8
  60:num2str.c     **** 			{
  61:num2str.c     **** 				if (pos < USINT2DECASCII_MAX_DIGITS - 1)	// Check position, so single "0" will be handled prope
 114               		.loc 1 61 5 is_stmt 1 view .LVU23
 115               		.loc 1 61 8 is_stmt 0 view .LVU24
 116 004e 2430      		cpi r18,lo8(4)
 117 0050 01F0      		breq .L8
  62:num2str.c     **** 					digit = -16;	// Use: "-16" for space (' '), "-3" for dash/minus ('-'), "0" for zero ('0'), etc
 118               		.loc 1 62 12 view .LVU25
 119 0052 90EF      		ldi r25,lo8(-16)
 120               	.LVL7:
 121               	.L4:
  63:num2str.c     **** 			}
  64:num2str.c     **** 			else
  65:num2str.c     **** 			{
  66:num2str.c     **** 				digits = pos;
  67:num2str.c     **** 			}
  68:num2str.c     **** 		}
  69:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
 122               		.loc 1 69 3 is_stmt 1 discriminator 2 view .LVU26
 123               		.loc 1 69 23 is_stmt 0 discriminator 2 view .LVU27
 124 0054 905D      		subi r25,lo8(-(48))
 125               	.LVL8:
 126               		.loc 1 69 15 discriminator 2 view .LVU28
 127 0056 9D93      		st X+,r25
  30:num2str.c     **** 	{
 128               		.loc 1 30 36 discriminator 2 view .LVU29
 129 0058 2F5F      		subi r18,lo8(-(1))
 130               	.LVL9:
  30:num2str.c     **** 	{
 131               		.loc 1 30 2 discriminator 2 view .LVU30
 132 005a 2530      		cpi r18,lo8(5)
 133 005c 01F4      		brne .L2
 134               	/* epilogue start */
 135               	.LBE3:
  70:num2str.c     **** 
  71:num2str.c     **** 	}
  72:num2str.c     **** 
  73:num2str.c     **** 	// NOTE: The resulting ascii text should not be terminated with '\0' here.
  74:num2str.c     **** 	//       The provided buffer maybe part of a larger text in both directions.
  75:num2str.c     **** 
  76:num2str.c     **** 	return digits;
  77:num2str.c     **** }
 136               		.loc 1 77 1 view .LVU31
 137 005e 2A96      		adiw r28,10
 138 0060 0FB6      		in __tmp_reg__,__SREG__
 139 0062 F894      		cli
 140 0064 DEBF      		out __SP_H__,r29
 141 0066 0FBE      		out __SREG__,__tmp_reg__
 142 0068 CDBF      		out __SP_L__,r28
 143 006a DF91      		pop r29
 144 006c CF91      		pop r28
 145 006e 0895      		ret
 146               	.LVL10:
 147               	.L8:
 148               	.LBB4:
 149               		.loc 1 77 1 view .LVU32
 150 0070 822F      		mov r24,r18
 151               	.LVL11:
 152               		.loc 1 77 1 view .LVU33
 153 0072 00C0      		rjmp .L4
 154               	.LBE4:
 155               		.cfi_endproc
 156               	.LFE0:
 158               	.global	usint2hexascii
 160               	usint2hexascii:
 161               	.LVL12:
 162               	.LFB1:
  78:num2str.c     **** 
  79:num2str.c     **** // ----------------------------------------------------------------------------
  80:num2str.c     **** 
  81:num2str.c     **** uint8_t usint2hexascii(uint16_t num, char *buffer) {
 163               		.loc 1 81 52 is_stmt 1 view -0
 164               		.cfi_startproc
 165               	/* prologue: function */
 166               	/* frame size = 0 */
 167               	/* stack size = 0 */
 168               	.L__stack_usage = 0
 169               		.loc 1 81 52 is_stmt 0 view .LVU35
 170 0074 9C01      		movw r18,r24
 171 0076 FB01      		movw r30,r22
  82:num2str.c     **** 	for (int8_t pos = USINT2HEXASCII_MAX_DIGITS - 1; pos >= 0 ; pos--) { // "pos" is index in an array
 172               		.loc 1 82 2 is_stmt 1 view .LVU36
 173               	.LBB5:
 174               		.loc 1 82 7 view .LVU37
 175               	.LVL13:
 176               		.loc 1 82 7 is_stmt 0 view .LVU38
 177               	.LBE5:
  81:num2str.c     **** 	for (int8_t pos = USINT2HEXASCII_MAX_DIGITS - 1; pos >= 0 ; pos--) { // "pos" is index in an array
 178               		.loc 1 81 52 view .LVU39
 179 0078 43E0      		ldi r20,lo8(3)
 180 007a 50E0      		ldi r21,0
 181               	.LVL14:
 182               	.L12:
 183               	.LBB8:
 184               	.LBB6:
  83:num2str.c     **** 		char digit = num & 0x000f;
 185               		.loc 1 83 3 is_stmt 1 view .LVU40
 186               		.loc 1 83 8 is_stmt 0 view .LVU41
 187 007c 822F      		mov r24,r18
 188 007e 8F70      		andi r24,lo8(15)
 189               	.LVL15:
  84:num2str.c     **** 		if (digit <= 9) {
 190               		.loc 1 84 3 is_stmt 1 view .LVU42
 191 0080 DF01      		movw r26,r30
 192 0082 A40F      		add r26,r20
 193 0084 B51F      		adc r27,r21
 194               		.loc 1 84 6 is_stmt 0 view .LVU43
 195 0086 8A30      		cpi r24,lo8(10)
 196 0088 00F4      		brsh .L10
  85:num2str.c     **** 			buffer[pos] = digit + '0';	// Convert to ASCII
 197               		.loc 1 85 4 is_stmt 1 view .LVU44
 198               		.loc 1 85 24 is_stmt 0 view .LVU45
 199 008a 805D      		subi r24,lo8(-(48))
 200               	.LVL16:
 201               	.L14:
  86:num2str.c     **** 		} else {
  87:num2str.c     **** 			buffer[pos] = digit + 'A' - 10;	// Convert to ASCII
 202               		.loc 1 87 16 view .LVU46
 203 008c 8C93      		st X,r24
  88:num2str.c     **** 		}
  89:num2str.c     **** 		num = num >> 4;
 204               		.loc 1 89 3 is_stmt 1 view .LVU47
 205               		.loc 1 89 7 is_stmt 0 view .LVU48
 206 008e 84E0      		ldi r24,4
 207               		1:
 208 0090 3695      		lsr r19
 209 0092 2795      		ror r18
 210 0094 8A95      		dec r24
 211 0096 01F4      		brne 1b
 212               	.LVL17:
 213               		.loc 1 89 7 view .LVU49
 214               	.LVL18:
 215               		.loc 1 89 7 view .LVU50
 216               	.LBE6:
 217 0098 4150      		subi r20,1
 218 009a 5109      		sbc r21,__zero_reg__
 219 009c 00F4      		brcc .L12
 220               	.LBE8:
  90:num2str.c     **** 	}
  91:num2str.c     **** 	return 4;
 221               		.loc 1 91 2 is_stmt 1 view .LVU51
  92:num2str.c     **** }
 222               		.loc 1 92 1 is_stmt 0 view .LVU52
 223 009e 84E0      		ldi r24,lo8(4)
 224               	/* epilogue start */
 225 00a0 0895      		ret
 226               	.LVL19:
 227               	.L10:
 228               	.LBB9:
 229               	.LBB7:
  87:num2str.c     **** 		}
 230               		.loc 1 87 4 is_stmt 1 view .LVU53
  87:num2str.c     **** 		}
 231               		.loc 1 87 30 is_stmt 0 view .LVU54
 232 00a2 895C      		subi r24,lo8(-(55))
 233               	.LVL20:
  87:num2str.c     **** 		}
 234               		.loc 1 87 30 view .LVU55
 235 00a4 00C0      		rjmp .L14
 236               	.LBE7:
 237               	.LBE9:
 238               		.cfi_endproc
 239               	.LFE1:
 241               	.global	usint2binascii
 243               	usint2binascii:
 244               	.LVL21:
 245               	.LFB2:
  93:num2str.c     **** 
  94:num2str.c     **** // ----------------------------------------------------------------------------
  95:num2str.c     **** 
  96:num2str.c     **** // NOTE: The buffer should be always at least MAX_DIGITS in length - the function works with 16-bit
  97:num2str.c     **** 
  98:num2str.c     **** uint8_t usint2binascii(uint16_t num, char *buffer) {
 246               		.loc 1 98 52 is_stmt 1 view -0
 247               		.cfi_startproc
 248               	/* prologue: function */
 249               	/* frame size = 0 */
 250               	/* stack size = 0 */
 251               	.L__stack_usage = 0
 252               		.loc 1 98 52 is_stmt 0 view .LVU57
 253 00a6 9C01      		movw r18,r24
 254 00a8 FB01      		movw r30,r22
  99:num2str.c     **** 	uint16_t power = 0x8000;	// This is the 1000 0000 0000 0000 binary number.
 255               		.loc 1 99 2 is_stmt 1 view .LVU58
 256               	.LVL22:
 100:num2str.c     **** 	char digit; // "digit" is stored in a char array, so it should be of type char.
 257               		.loc 1 100 2 view .LVU59
 101:num2str.c     **** 	uint8_t digits = USINT2BINASCII_MAX_DIGITS - 1;
 258               		.loc 1 101 2 view .LVU60
 102:num2str.c     **** 	for (uint8_t pos = 0; pos < USINT2BINASCII_MAX_DIGITS; pos++) { // "pos" is index in an array.
 259               		.loc 1 102 2 view .LVU61
 260               	.LBB10:
 261               		.loc 1 102 7 view .LVU62
 262               		.loc 1 102 15 is_stmt 0 view .LVU63
 263 00aa 40E0      		ldi r20,0
 264               	.LBE10:
 101:num2str.c     **** 	uint8_t digits = USINT2BINASCII_MAX_DIGITS - 1;
 265               		.loc 1 101 10 view .LVU64
 266 00ac 8FE0      		ldi r24,lo8(15)
 267               	.LVL23:
  99:num2str.c     **** 	char digit; // "digit" is stored in a char array, so it should be of type char.
 268               		.loc 1 99 11 view .LVU65
 269 00ae 60E0      		ldi r22,0
 270 00b0 70E8      		ldi r23,lo8(-128)
 271               	.LVL24:
 272               	.L17:
 273               	.LBB11:
 103:num2str.c     **** 		digit = 0;
 274               		.loc 1 103 3 is_stmt 1 view .LVU66
 104:num2str.c     **** 		if (num >= power) {
 275               		.loc 1 104 3 view .LVU67
 276 00b2 90E0      		ldi r25,0
 277               		.loc 1 104 6 is_stmt 0 view .LVU68
 278 00b4 2617      		cp r18,r22
 279 00b6 3707      		cpc r19,r23
 280 00b8 00F0      		brlo .L16
 105:num2str.c     **** 			digit++;
 281               		.loc 1 105 4 is_stmt 1 view .LVU69
 282               	.LVL25:
 106:num2str.c     **** 			num -= power;
 283               		.loc 1 106 4 view .LVU70
 284               		.loc 1 106 8 is_stmt 0 view .LVU71
 285 00ba 261B      		sub r18,r22
 286 00bc 370B      		sbc r19,r23
 287               	.LVL26:
 107:num2str.c     **** 		}
 108:num2str.c     **** 		// Fixed width, space ('0', or anything else) padded result, digits offset.
 109:num2str.c     **** 		// Note: Determines the offset of the first significant digit.
 110:num2str.c     **** 		// Note: Could be used for variable width, not padded, left aligned result.
 111:num2str.c     **** 		if (digits == USINT2BINASCII_MAX_DIGITS - 1) {
 288               		.loc 1 111 3 is_stmt 1 view .LVU72
 289               		.loc 1 111 6 is_stmt 0 view .LVU73
 290 00be 8F30      		cpi r24,lo8(15)
 291 00c0 01F4      		brne .L19
 292 00c2 842F      		mov r24,r20
 293               	.LVL27:
 294               	.L19:
 105:num2str.c     **** 			num -= power;
 295               		.loc 1 105 9 view .LVU74
 296 00c4 91E0      		ldi r25,lo8(1)
 297               	.LVL28:
 298               	.L16:
 112:num2str.c     **** 			if (digit == 0) {
 113:num2str.c     **** 				if (pos < USINT2BINASCII_MAX_DIGITS - 1) // Check position, so single "0" will be handled prope
 114:num2str.c     **** 					digit = 0; // Use: "-16" for space (' '), "-3" for dash/minus ('-'), "0" for zero ('0'), etc.
 115:num2str.c     **** 			} else {
 116:num2str.c     **** 				digits = pos;
 117:num2str.c     **** 			}
 118:num2str.c     **** 		}
 119:num2str.c     **** 		buffer[pos] = digit + '0';	// Convert to ASCII
 299               		.loc 1 119 3 is_stmt 1 discriminator 2 view .LVU75
 300               		.loc 1 119 23 is_stmt 0 discriminator 2 view .LVU76
 301 00c6 905D      		subi r25,lo8(-(48))
 302               	.LVL29:
 303               		.loc 1 119 15 discriminator 2 view .LVU77
 304 00c8 9193      		st Z+,r25
 120:num2str.c     **** 		power = power >> 1;
 305               		.loc 1 120 3 is_stmt 1 discriminator 2 view .LVU78
 306               		.loc 1 120 9 is_stmt 0 discriminator 2 view .LVU79
 307 00ca 7695      		lsr r23
 308 00cc 6795      		ror r22
 309               	.LVL30:
 102:num2str.c     **** 		digit = 0;
 310               		.loc 1 102 37 discriminator 2 view .LVU80
 311 00ce 4F5F      		subi r20,lo8(-(1))
 312               	.LVL31:
 102:num2str.c     **** 		digit = 0;
 313               		.loc 1 102 2 discriminator 2 view .LVU81
 314 00d0 4031      		cpi r20,lo8(16)
 315 00d2 01F4      		brne .L17
 316               	/* epilogue start */
 102:num2str.c     **** 		digit = 0;
 317               		.loc 1 102 2 discriminator 2 view .LVU82
 318               	.LBE11:
 121:num2str.c     **** 	}
 122:num2str.c     **** 	// NOTE: The resulting ascii text should not be terminated with '\0' here.
 123:num2str.c     **** 	//       The provided buffer maybe part of a larger text in both directions.
 124:num2str.c     **** 	return digits;
 125:num2str.c     **** }
 319               		.loc 1 125 1 view .LVU83
 320 00d4 0895      		ret
 321               		.cfi_endproc
 322               	.LFE2:
 324               	.Letext0:
 325               		.file 2 "/usr/local/Cellar/avr-gcc/9.1.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 num2str.c
           num2str.s:2      *ABS*:000000000000003e __SP_H__
           num2str.s:3      *ABS*:000000000000003d __SP_L__
           num2str.s:4      *ABS*:000000000000003f __SREG__
           num2str.s:5      *ABS*:0000000000000000 __tmp_reg__
           num2str.s:6      *ABS*:0000000000000001 __zero_reg__
           num2str.s:20     .text:0000000000000000 usint2decascii
           num2str.s:160    .text:0000000000000074 usint2hexascii
           num2str.s:243    .text:00000000000000a6 usint2binascii

UNDEFINED SYMBOLS
__do_copy_data
