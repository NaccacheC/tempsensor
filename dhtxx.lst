   1               		.file	"dhtxx.c"
   2               	__SP_H__ = 0x3e
   3               	__SP_L__ = 0x3d
   4               	__SREG__ = 0x3f
   5               	__tmp_reg__ = 0
   6               	__zero_reg__ = 1
   7               		.text
   8               	.Ltext0:
   9               		.cfi_sections	.debug_frame
  10               	.global	dhtxxread
  12               	dhtxxread:
  13               	.LVL0:
  14               	.LFB7:
  15               		.file 1 "dhtxx.c"
   1:dhtxx.c       **** /* dhtxx.c - a part of avr-dhtxx library
   2:dhtxx.c       ****  *
   3:dhtxx.c       ****  * Copyright (C) 2016 Jacek Wieczorek
   4:dhtxx.c       ****  *
   5:dhtxx.c       ****  * This software may be modified and distributed under the terms
   6:dhtxx.c       ****  * of the MIT license.	See the LICENSE file for details.
   7:dhtxx.c       ****  */
   8:dhtxx.c       **** 
   9:dhtxx.c       **** #include <inttypes.h>
  10:dhtxx.c       **** #include <avr/io.h>
  11:dhtxx.c       **** #include <util/delay.h>
  12:dhtxx.c       **** #include <avr/interrupt.h>
  13:dhtxx.c       **** 
  14:dhtxx.c       **** #include "dhtxx.h"
  15:dhtxx.c       **** 
  16:dhtxx.c       **** #ifndef DHTXX_TIMEOUT
  17:dhtxx.c       **** #define DHTXX_TIMEOUT 60
  18:dhtxx.c       **** #endif
  19:dhtxx.c       **** 
  20:dhtxx.c       **** #if DHTXX_TIMEOUT > 255
  21:dhtxx.c       **** #error "DHTXX_TIMEOUT cannot take values greater than 255!"
  22:dhtxx.c       **** #endif
  23:dhtxx.c       **** 
  24:dhtxx.c       **** /*
  25:dhtxx.c       **** - 20ms start signal
  26:dhtxx.c       **** - 20 - 40us response timeout
  27:dhtxx.c       **** - 80us presence acknowledgement
  28:dhtxx.c       **** - 80us of pause
  29:dhtxx.c       **** 
  30:dhtxx.c       **** - 50us of sync impulse
  31:dhtxx.c       **** - 28us / 70us data impulse
  32:dhtxx.c       **** */
  33:dhtxx.c       **** 
  34:dhtxx.c       **** static uint8_t dhtxxreadb( volatile uint8_t *port, volatile uint8_t *direction, volatile uint8_t *p
  35:dhtxx.c       **** {
  36:dhtxx.c       **** 	uint8_t sreg = SREG; //Backup status register
  37:dhtxx.c       **** 	uint8_t data = 0;
  38:dhtxx.c       **** 	uint8_t timeoutcnt = 0;
  39:dhtxx.c       **** 	uint8_t i = 0;
  40:dhtxx.c       **** 
  41:dhtxx.c       **** 	//Disable interrupts
  42:dhtxx.c       **** 	cli( );
  43:dhtxx.c       **** 
  44:dhtxx.c       **** 	//Turn pin into input
  45:dhtxx.c       **** 	*direction &= ~mask;
  46:dhtxx.c       **** 	*port &= ~mask;
  47:dhtxx.c       **** 
  48:dhtxx.c       **** 	//Get 8 bits
  49:dhtxx.c       **** 	for ( i = 128; i; i >>= 1 )
  50:dhtxx.c       **** 	{
  51:dhtxx.c       **** 		//Wait for the sync part to finish
  52:dhtxx.c       **** 		timeoutcnt = 0;
  53:dhtxx.c       **** 		while ( !( *portin & mask ) )
  54:dhtxx.c       **** 		{
  55:dhtxx.c       **** 			if ( timeoutcnt++ > DHTXX_TIMEOUT )
  56:dhtxx.c       **** 			{
  57:dhtxx.c       **** 				SREG = sreg;
  58:dhtxx.c       **** 				return DHTXX_ERROR_COMM;
  59:dhtxx.c       **** 			}
  60:dhtxx.c       **** 			_delay_us( 1 );
  61:dhtxx.c       **** 		}
  62:dhtxx.c       **** 
  63:dhtxx.c       **** 		_delay_us( 30 );
  64:dhtxx.c       **** 
  65:dhtxx.c       **** 		if ( *portin & mask ) data |= i;
  66:dhtxx.c       **** 
  67:dhtxx.c       **** 		//Wait for the data part to finish
  68:dhtxx.c       **** 		timeoutcnt = 0;
  69:dhtxx.c       **** 		while ( *portin & mask )
  70:dhtxx.c       **** 		{
  71:dhtxx.c       **** 			if ( timeoutcnt++ > DHTXX_TIMEOUT )
  72:dhtxx.c       **** 			{
  73:dhtxx.c       **** 				SREG = sreg;
  74:dhtxx.c       **** 				return DHTXX_ERROR_COMM;
  75:dhtxx.c       **** 			}
  76:dhtxx.c       **** 			_delay_us( 1 );
  77:dhtxx.c       **** 		}
  78:dhtxx.c       **** 	}
  79:dhtxx.c       **** 
  80:dhtxx.c       **** 	*dest = data;
  81:dhtxx.c       **** 
  82:dhtxx.c       **** 	SREG = sreg;
  83:dhtxx.c       **** 	return DHTXX_ERROR_OK;
  84:dhtxx.c       **** }
  85:dhtxx.c       **** 
  86:dhtxx.c       **** uint8_t dhtxxread( unsigned char dev, volatile uint8_t *port, volatile uint8_t *direction, volatile
  87:dhtxx.c       **** {
  16               		.loc 1 87 1 view -0
  17               		.cfi_startproc
  18               		.loc 1 87 1 is_stmt 0 view .LVU1
  19 0000 4F92      		push r4
  20               	.LCFI0:
  21               		.cfi_def_cfa_offset 3
  22               		.cfi_offset 4, -2
  23 0002 5F92      		push r5
  24               	.LCFI1:
  25               		.cfi_def_cfa_offset 4
  26               		.cfi_offset 5, -3
  27 0004 7F92      		push r7
  28               	.LCFI2:
  29               		.cfi_def_cfa_offset 5
  30               		.cfi_offset 7, -4
  31 0006 8F92      		push r8
  32               	.LCFI3:
  33               		.cfi_def_cfa_offset 6
  34               		.cfi_offset 8, -5
  35 0008 9F92      		push r9
  36               	.LCFI4:
  37               		.cfi_def_cfa_offset 7
  38               		.cfi_offset 9, -6
  39 000a AF92      		push r10
  40               	.LCFI5:
  41               		.cfi_def_cfa_offset 8
  42               		.cfi_offset 10, -7
  43 000c BF92      		push r11
  44               	.LCFI6:
  45               		.cfi_def_cfa_offset 9
  46               		.cfi_offset 11, -8
  47 000e CF92      		push r12
  48               	.LCFI7:
  49               		.cfi_def_cfa_offset 10
  50               		.cfi_offset 12, -9
  51 0010 DF92      		push r13
  52               	.LCFI8:
  53               		.cfi_def_cfa_offset 11
  54               		.cfi_offset 13, -10
  55 0012 EF92      		push r14
  56               	.LCFI9:
  57               		.cfi_def_cfa_offset 12
  58               		.cfi_offset 14, -11
  59 0014 FF92      		push r15
  60               	.LCFI10:
  61               		.cfi_def_cfa_offset 13
  62               		.cfi_offset 15, -12
  63 0016 0F93      		push r16
  64               	.LCFI11:
  65               		.cfi_def_cfa_offset 14
  66               		.cfi_offset 16, -13
  67 0018 1F93      		push r17
  68               	.LCFI12:
  69               		.cfi_def_cfa_offset 15
  70               		.cfi_offset 17, -14
  71 001a CF93      		push r28
  72               	.LCFI13:
  73               		.cfi_def_cfa_offset 16
  74               		.cfi_offset 28, -15
  75 001c DF93      		push r29
  76               	.LCFI14:
  77               		.cfi_def_cfa_offset 17
  78               		.cfi_offset 29, -16
  79 001e 00D0      		rcall .
  80 0020 00D0      		rcall .
  81 0022 0F92      		push __tmp_reg__
  82               	.LCFI15:
  83               		.cfi_def_cfa_offset 22
  84 0024 CDB7      		in r28,__SP_L__
  85 0026 DEB7      		in r29,__SP_H__
  86               	.LCFI16:
  87               		.cfi_def_cfa_register 28
  88               	/* prologue: function */
  89               	/* frame size = 5 */
  90               	/* stack size = 20 */
  91               	.L__stack_usage = 20
  92 0028 182F      		mov r17,r24
  93 002a 4B01      		movw r8,r22
  94 002c FA01      		movw r30,r20
  95 002e 2901      		movw r4,r18
  96 0030 5701      		movw r10,r14
  97 0032 7601      		movw r14,r12
  98               	.LVL1:
  88:dhtxx.c       **** 	uint8_t sreg = SREG; //Status register backup
  99               		.loc 1 88 2 is_stmt 1 view .LVU2
 100               		.loc 1 88 10 is_stmt 0 view .LVU3
 101 0034 9FB7      		in r25,__SREG__
 102               	.LVL2:
  89:dhtxx.c       **** 	uint8_t data[5]; //Data received from sensor
 103               		.loc 1 89 2 is_stmt 1 view .LVU4
  90:dhtxx.c       **** 	uint8_t cs = 0; //Checksum
 104               		.loc 1 90 2 view .LVU5
  91:dhtxx.c       **** 	uint8_t ec = 0;
 105               		.loc 1 91 2 view .LVU6
  92:dhtxx.c       **** 	uint8_t i;
 106               		.loc 1 92 2 view .LVU7
  93:dhtxx.c       **** 
  94:dhtxx.c       **** 	//Check if device type is correct
  95:dhtxx.c       **** 	if ( dev != DHTXX_DHT11 && dev != DHTXX_DHT22 ) return DHTXX_ERROR_OTHER;
 107               		.loc 1 95 2 view .LVU8
 108               		.loc 1 95 37 is_stmt 0 view .LVU9
 109 0036 23E0      		ldi r18,lo8(3)
 110               	.LVL3:
 111               		.loc 1 95 5 view .LVU10
 112 0038 8230      		cpi r24,lo8(2)
 113 003a 00F4      		brsh .L1
  96:dhtxx.c       **** 
  97:dhtxx.c       **** 	//Send start signal
  98:dhtxx.c       **** 	*direction &= ~mask;
 114               		.loc 1 98 2 is_stmt 1 view .LVU11
 115               		.loc 1 98 13 is_stmt 0 view .LVU12
 116 003c 2081      		ld r18,Z
 117 003e 802F      		mov r24,r16
 118               	.LVL4:
 119               		.loc 1 98 13 view .LVU13
 120 0040 8095      		com r24
 121 0042 2823      		and r18,r24
 122 0044 2083      		st Z,r18
  99:dhtxx.c       **** 	*port &= ~mask;
 123               		.loc 1 99 2 is_stmt 1 view .LVU14
 124               		.loc 1 99 8 is_stmt 0 view .LVU15
 125 0046 DB01      		movw r26,r22
 126 0048 2C91      		ld r18,X
 127 004a 2823      		and r18,r24
 128 004c 2C93      		st X,r18
 100:dhtxx.c       **** 	*direction |= mask;
 129               		.loc 1 100 2 is_stmt 1 view .LVU16
 130               		.loc 1 100 13 is_stmt 0 view .LVU17
 131 004e 2081      		ld r18,Z
 132 0050 202B      		or r18,r16
 133 0052 2083      		st Z,r18
 101:dhtxx.c       **** 
 102:dhtxx.c       **** 	//Adjust start signal time for DHT11 and DHT22
 103:dhtxx.c       **** 	if ( dev == DHTXX_DHT22 )
 134               		.loc 1 103 2 is_stmt 1 view .LVU18
 135               		.loc 1 103 5 is_stmt 0 view .LVU19
 136 0054 1130      		cpi r17,lo8(1)
 137 0056 01F4      		brne .L3
 104:dhtxx.c       **** 		_delay_us( 500 );
 138               		.loc 1 104 3 is_stmt 1 view .LVU20
 139               	.LVL5:
 140               	.LBB42:
 141               	.LBI42:
 142               		.file 2 "/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h"
   1:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /* Copyright (c) 2002, Marek Michalkiewicz
   2:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Copyright (c) 2004,2005,2007 Joerg Wunsch
   3:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Copyright (c) 2007  Florin-Viorel Petrov
   4:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    All rights reserved.
   5:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
   6:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Redistribution and use in source and binary forms, with or without
   7:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    modification, are permitted provided that the following conditions are met:
   8:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
   9:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    * Redistributions of source code must retain the above copyright
  10:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer.
  11:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  12:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    * Redistributions in binary form must reproduce the above copyright
  13:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****      notice, this list of conditions and the following disclaimer in
  14:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****      the documentation and/or other materials provided with the
  15:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****      distribution.
  16:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  17:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    * Neither the name of the copyright holders nor the names of
  18:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****      contributors may be used to endorse or promote products derived
  19:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****      from this software without specific prior written permission.
  20:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  21:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   THIS SOFTWARE IS PROVIDED BY THE COPYRIGHT HOLDERS AND CONTRIBUTORS "AS IS"
  22:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   AND ANY EXPRESS OR IMPLIED WARRANTIES, INCLUDING, BUT NOT LIMITED TO, THE
  23:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   IMPLIED WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE
  24:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   ARE DISCLAIMED. IN NO EVENT SHALL THE COPYRIGHT OWNER OR CONTRIBUTORS BE
  25:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   LIABLE FOR ANY DIRECT, INDIRECT, INCIDENTAL, SPECIAL, EXEMPLARY, OR
  26:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   CONSEQUENTIAL DAMAGES (INCLUDING, BUT NOT LIMITED TO, PROCUREMENT OF
  27:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   SUBSTITUTE GOODS OR SERVICES; LOSS OF USE, DATA, OR PROFITS; OR BUSINESS
  28:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   INTERRUPTION) HOWEVER CAUSED AND ON ANY THEORY OF LIABILITY, WHETHER IN
  29:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   CONTRACT, STRICT LIABILITY, OR TORT (INCLUDING NEGLIGENCE OR OTHERWISE)
  30:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   ARISING IN ANY WAY OUT OF THE USE OF THIS SOFTWARE, EVEN IF ADVISED OF THE
  31:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   POSSIBILITY OF SUCH DAMAGE. */
  32:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  33:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /* $Id: delay.h.in 2506 2016-02-08 10:05:45Z joerg_wunsch $ */
  34:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  35:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #ifndef _UTIL_DELAY_H_
  36:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #define _UTIL_DELAY_H_ 1
  37:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  38:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #ifndef __DOXYGEN__
  39:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #  ifndef __HAS_DELAY_CYCLES
  40:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #    define __HAS_DELAY_CYCLES 1
  41:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #  endif
  42:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif  /* __DOXYGEN__ */
  43:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  44:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #include <inttypes.h>
  45:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #include <util/delay_basic.h>
  46:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #include <math.h>
  47:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  48:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /** \file */
  49:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /** \defgroup util_delay <util/delay.h>: Convenience functions for busy-wait delay loops
  50:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     \code
  51:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     #define F_CPU 1000000UL  // 1 MHz
  52:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     //#define F_CPU 14.7456E6
  53:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     #include <util/delay.h>
  54:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     \endcode
  55:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  56:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     \note As an alternative method, it is possible to pass the
  57:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     F_CPU macro down to the compiler from the Makefile.
  58:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     Obviously, in that case, no \c \#define statement should be
  59:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     used.
  60:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  61:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     The functions in this header file are wrappers around the basic
  62:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     busy-wait functions from <util/delay_basic.h>.  They are meant as
  63:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     convenience functions where actual time values can be specified
  64:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     rather than a number of cycles to wait for.  The idea behind is
  65:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     that compile-time constant expressions will be eliminated by
  66:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     compiler optimization so floating-point expressions can be used
  67:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     to calculate the number of delay cycles needed based on the CPU
  68:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     frequency passed by the macro F_CPU.
  69:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  70:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     \note In order for these functions to work as intended, compiler
  71:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     optimizations <em>must</em> be enabled, and the delay time
  72:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     <em>must</em> be an expression that is a known constant at
  73:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     compile-time.  If these requirements are not met, the resulting
  74:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     delay will be much longer (and basically unpredictable), and
  75:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     applications that otherwise do not use floating-point calculations
  76:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     will experience severe code bloat by the floating-point library
  77:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     routines linked into the application.
  78:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  79:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     The functions available allow the specification of microsecond, and
  80:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     millisecond delays directly, using the application-supplied macro
  81:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     F_CPU as the CPU clock frequency (in Hertz).
  82:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  83:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** */
  84:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  85:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if !defined(__DOXYGEN__)
  86:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** static __inline__ void _delay_us(double __us) __attribute__((__always_inline__));
  87:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** static __inline__ void _delay_ms(double __ms) __attribute__((__always_inline__));
  88:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif
  89:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  90:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #ifndef F_CPU
  91:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /* prevent compiler error by supplying a default */
  92:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** # warning "F_CPU not defined for <util/delay.h>"
  93:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /** \ingroup util_delay
  94:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     \def F_CPU
  95:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     \brief CPU frequency in Hz
  96:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
  97:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     The macro F_CPU specifies the CPU frequency to be considered by
  98:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     the delay macros.  This macro is normally supplied by the
  99:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     environment (e.g. from within a project header, or the project's
 100:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     Makefile).  The value 1 MHz here is only provided as a "vanilla"
 101:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     fallback if no such user-provided definition could be found.
 102:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 103:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     In terms of the delay functions, the CPU frequency can be given as
 104:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     a floating-point constant (e.g. 3.6864E6 for 3.6864 MHz).
 105:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     However, the macros in <util/setbaud.h> require it to be an
 106:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****     integer value.
 107:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****  */
 108:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** # define F_CPU 1000000UL
 109:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif
 110:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 111:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #ifndef __OPTIMIZE__
 112:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** # warning "Compiler optimizations disabled; functions from <util/delay.h> won't work as designed"
 113:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif
 114:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 115:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 116:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 117:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 118:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #  include <math.h>
 119:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif
 120:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 121:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /**
 122:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 123:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 124:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Perform a delay of \c __ms milliseconds, using _delay_loop_2().
 125:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 126:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 127:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 128:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 129:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    The maximal possible delay is 262.14 ms / F_CPU in MHz.
 130:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 131:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    When the user request delay which exceed the maximum possible one,
 132:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    _delay_ms() provides a decreased resolution functionality. In this
 133:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    mode _delay_ms() will work with a resolution of 1/10 ms, providing
 134:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    delays up to 6.5535 seconds (independent from CPU frequency).  The
 135:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    user will not be informed about decreased resolution.
 136:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 137:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 138:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 ms/ F_CPU in MHz. For
 139:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflows results in
 140:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    no delay i.e., 0ms.
 141:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 142:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Conversion of \c __ms into clock cycles may not always result in
 143:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 144:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __ms
 145:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    microseconds of delay.
 146:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 147:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 148:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 149:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 150:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    respectively.
 151:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 152:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \note
 153:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 154:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 155:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 156:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 157:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c "__DELAY_BACKWARD_COMPATIBLE__"
 158:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 159:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 160:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 161:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 162:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 163:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 164:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****  */
 165:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** void
 166:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** _delay_ms(double __ms)
 167:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 168:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	double __tmp ;
 169:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 170:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 171:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 172:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 173:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 174:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 175:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 176:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 177:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 178:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 179:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 180:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 181:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 182:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#else
 183:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		//round up by default
 184:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 185:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 186:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 187:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 188:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 189:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #else
 190:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	uint16_t __ticks;
 191:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 4e3) * __ms;
 192:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 193:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks = 1;
 194:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	else if (__tmp > 65535)
 195:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	{
 196:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		//	__ticks = requested delay in 1/10 ms
 197:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks = (uint16_t) (__ms * 10.0);
 198:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		while(__ticks)
 199:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		{
 200:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 			// wait 1/10 ms
 201:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 			_delay_loop_2(((F_CPU) / 4e3) / 10);
 202:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 			__ticks --;
 203:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		}
 204:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		return;
 205:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	}
 206:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	else
 207:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks = (uint16_t)__tmp;
 208:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	_delay_loop_2(__ticks);
 209:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif
 210:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** }
 211:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 212:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** /**
 213:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \ingroup util_delay
 214:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 215:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Perform a delay of \c __us microseconds, using _delay_loop_1().
 216:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 217:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    The macro F_CPU is supposed to be defined to a
 218:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    constant defining the CPU clock frequency (in Hertz).
 219:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 220:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    The maximal possible delay is 768 us / F_CPU in MHz.
 221:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 222:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    If the user requests a delay greater than the maximal possible one,
 223:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    _delay_us() will automatically call _delay_ms() instead.  The user
 224:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    will not be informed about this case.
 225:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 226:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    If the avr-gcc toolchain has __builtin_avr_delay_cycles()
 227:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    support, maximal possible delay is 4294967.295 us/ F_CPU in MHz. For
 228:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    values greater than the maximal possible delay, overflow results in
 229:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    no delay i.e., 0us.
 230:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 231:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Conversion of \c __us into clock cycles may not always result in
 232:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    integer.  By default, the clock cycles rounded up to next
 233:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    integer. This ensures that the user gets at least \c __us
 234:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    microseconds of delay.
 235:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 236:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    Alternatively, by defining the macro \c __DELAY_ROUND_DOWN__, or
 237:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \c __DELAY_ROUND_CLOSEST__, before including this header file, the
 238:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    algorithm can be made to round down, or round to closest integer,
 239:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    respectively.
 240:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 241:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \note
 242:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 243:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    The implementation of _delay_ms() based on
 244:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    __builtin_avr_delay_cycles() is not backward compatible with older
 245:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    implementations.  In order to get functionality backward compatible
 246:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    with previous versions, the macro \c __DELAY_BACKWARD_COMPATIBLE__
 247:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    must be defined before including this header file. Also, the
 248:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    backward compatible algorithm will be chosen if the code is
 249:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    compiled in a <em>freestanding environment</em> (GCC option
 250:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    \c -ffreestanding), as the math functions required for rounding are
 251:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****    not available to the compiler then.
 252:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 253:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****  */
 254:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** void
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** _delay_us(double __us)
 143               		.loc 2 255 1 view .LVU21
 144               	.LBB43:
 256:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	double __tmp ;
 145               		.loc 2 257 2 view .LVU22
 258:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 259:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   !defined(__DELAY_BACKWARD_COMPATIBLE__) &&	   \
 260:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h ****   __STDC_HOSTED__
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	uint32_t __ticks_dc;
 146               		.loc 2 261 2 view .LVU23
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 147               		.loc 2 262 2 view .LVU24
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 148               		.loc 2 263 2 view .LVU25
 264:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 265:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#if defined(__DELAY_ROUND_DOWN__)
 266:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)fabs(__tmp);
 267:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 268:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#elif defined(__DELAY_ROUND_CLOSEST__)
 269:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(fabs(__tmp)+0.5);
 270:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 271:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#else
 272:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		//round up by default
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks_dc = (uint32_t)(ceil(fabs(__tmp)));
 149               		.loc 2 273 3 view .LVU26
 274:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 275:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 276:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__builtin_avr_delay_cycles(__ticks_dc);
 150               		.loc 2 276 2 view .LVU27
 151 0058 B6EA      		ldi r27,lo8(-90)
 152 005a BA95      	1:	dec r27
 153 005c 01F4      		brne 1b
 154 005e 00C0      		rjmp .
 155               	.LVL6:
 156               	.L4:
 157               		.loc 2 276 2 is_stmt 0 view .LVU28
 158               	.LBE43:
 159               	.LBE42:
 105:dhtxx.c       **** 	else
 106:dhtxx.c       **** 		_delay_ms( 18 );
 107:dhtxx.c       **** 
 108:dhtxx.c       **** 	//Turn pin into input, disable interrupts and wait for acknowledgement
 109:dhtxx.c       **** 	cli( );
 160               		.loc 1 109 1 is_stmt 1 view .LVU29
 161               	/* #APP */
 162               	 ;  109 "dhtxx.c" 1
 163 0060 F894      		cli
 164               	 ;  0 "" 2
 110:dhtxx.c       **** 	*direction &= ~mask;
 165               		.loc 1 110 2 view .LVU30
 166               		.loc 1 110 13 is_stmt 0 view .LVU31
 167               	/* #NOAPP */
 168 0062 2081      		ld r18,Z
 169 0064 2823      		and r18,r24
 170 0066 2083      		st Z,r18
 111:dhtxx.c       **** 	_delay_us( 30 + 40 );
 171               		.loc 1 111 2 is_stmt 1 view .LVU32
 172               	.LVL7:
 173               	.LBB44:
 174               	.LBI44:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 175               		.loc 2 255 1 view .LVU33
 176               	.LBB45:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 177               		.loc 2 257 2 view .LVU34
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 178               		.loc 2 261 2 view .LVU35
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 179               		.loc 2 262 2 view .LVU36
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 180               		.loc 2 263 2 view .LVU37
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 181               		.loc 2 273 3 view .LVU38
 182               		.loc 2 276 2 view .LVU39
 183 0068 B7E1      		ldi r27,lo8(23)
 184 006a BA95      	1:	dec r27
 185 006c 01F4      		brne 1b
 186 006e 0000      		nop
 187               	.LVL8:
 188               		.loc 2 276 2 is_stmt 0 view .LVU40
 189               	.LBE45:
 190               	.LBE44:
 112:dhtxx.c       **** 
 113:dhtxx.c       **** 	//Communication check 1
 114:dhtxx.c       **** 	if ( *portin & mask )
 191               		.loc 1 114 2 is_stmt 1 view .LVU41
 192               		.loc 1 114 7 is_stmt 0 view .LVU42
 193 0070 D201      		movw r26,r4
 194 0072 2C91      		ld r18,X
 195 0074 2023      		and r18,r16
 196               		.loc 1 114 5 view .LVU43
 197 0076 01F0      		breq .L5
 198               	.LVL9:
 199               	.L26:
 200               	.LBB46:
 201               	.LBB47:
  57:dhtxx.c       **** 				return DHTXX_ERROR_COMM;
 202               		.loc 1 57 4 is_stmt 1 view .LVU44
  57:dhtxx.c       **** 				return DHTXX_ERROR_COMM;
 203               		.loc 1 57 9 is_stmt 0 view .LVU45
 204 0078 9FBF      		out __SREG__,r25
 205 007a 00C0      		rjmp .L25
 206               	.LVL10:
 207               	.L3:
  57:dhtxx.c       **** 				return DHTXX_ERROR_COMM;
 208               		.loc 1 57 9 view .LVU46
 209               	.LBE47:
 210               	.LBE46:
 106:dhtxx.c       **** 
 211               		.loc 1 106 3 is_stmt 1 view .LVU47
 212               	.LBB59:
 213               	.LBI59:
 166:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 214               		.loc 2 166 1 view .LVU48
 215               	.LBB60:
 168:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 216               		.loc 2 168 2 view .LVU49
 172:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 217               		.loc 2 172 2 view .LVU50
 173:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 218               		.loc 2 173 2 view .LVU51
 174:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 219               		.loc 2 174 2 view .LVU52
 184:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 220               		.loc 2 184 3 view .LVU53
 187:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 221               		.loc 2 187 2 view .LVU54
 222 007c A3E9      		ldi r26,lo8(4499)
 223 007e B1E1      		ldi r27,hi8(4499)
 224 0080 1197      	1:	sbiw r26,1
 225 0082 01F4      		brne 1b
 226 0084 00C0      		rjmp .
 227 0086 0000      		nop
 210:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 228               		.loc 2 210 1 is_stmt 0 view .LVU55
 229 0088 00C0      		rjmp .L4
 230               	.LVL11:
 231               	.L5:
 210:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 232               		.loc 2 210 1 view .LVU56
 233               	.LBE60:
 234               	.LBE59:
 115:dhtxx.c       **** 	{
 116:dhtxx.c       **** 		SREG = sreg;
 117:dhtxx.c       **** 		return DHTXX_ERROR_COMM;
 118:dhtxx.c       **** 	}
 119:dhtxx.c       **** 
 120:dhtxx.c       **** 	_delay_us( 80 );
 235               		.loc 1 120 2 is_stmt 1 view .LVU57
 236               	.LBB61:
 237               	.LBI61:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 238               		.loc 2 255 1 view .LVU58
 239               	.LBB62:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 240               		.loc 2 257 2 view .LVU59
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 241               		.loc 2 261 2 view .LVU60
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 242               		.loc 2 262 2 view .LVU61
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 243               		.loc 2 263 2 view .LVU62
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 244               		.loc 2 273 3 view .LVU63
 245               		.loc 2 276 2 view .LVU64
 246 008a BAE1      		ldi r27,lo8(26)
 247 008c BA95      	1:	dec r27
 248 008e 01F4      		brne 1b
 249 0090 00C0      		rjmp .
 250               	.LVL12:
 251               		.loc 2 276 2 is_stmt 0 view .LVU65
 252               	.LBE62:
 253               	.LBE61:
 121:dhtxx.c       **** 
 122:dhtxx.c       **** 	//Communication check 2
 123:dhtxx.c       **** 	if ( !( *portin & mask ) )
 254               		.loc 1 123 2 is_stmt 1 view .LVU66
 255               		.loc 1 123 10 is_stmt 0 view .LVU67
 256 0092 D201      		movw r26,r4
 257 0094 2C91      		ld r18,X
 258               		.loc 1 123 7 view .LVU68
 259 0096 2023      		and r18,r16
 124:dhtxx.c       **** 	{
 125:dhtxx.c       **** 		SREG = sreg;
 260               		.loc 1 125 7 view .LVU69
 261 0098 9FBF      		out __SREG__,r25
 123:dhtxx.c       **** 	{
 262               		.loc 1 123 5 view .LVU70
 263 009a 2111      		cpse r18,__zero_reg__
 264 009c 00C0      		rjmp .L6
 265               	.LVL13:
 266               	.L25:
 267               	.LBB63:
 268               	.LBB54:
  58:dhtxx.c       **** 			}
 269               		.loc 1 58 5 is_stmt 1 view .LVU71
  58:dhtxx.c       **** 			}
 270               		.loc 1 58 5 is_stmt 0 view .LVU72
 271               	.LBE54:
 272               	.LBE63:
 126:dhtxx.c       **** 		return DHTXX_ERROR_COMM;
 127:dhtxx.c       **** 	}
 128:dhtxx.c       **** 
 129:dhtxx.c       **** 	//Restore interrupts status
 130:dhtxx.c       **** 	SREG = sreg;
 131:dhtxx.c       **** 	_delay_us( 40 );
 132:dhtxx.c       **** 
 133:dhtxx.c       **** 	//Read data from sensor
 134:dhtxx.c       **** 	for ( i = 0; i < 5; i++ )
 135:dhtxx.c       **** 	{
 136:dhtxx.c       **** 		ec = dhtxxreadb( port, direction, portin, mask, &data[i] );
 137:dhtxx.c       **** 		if ( ec ) return ec;
 273               		.loc 1 137 3 is_stmt 1 view .LVU73
 274               	.LBB64:
 275               	.LBB55:
  58:dhtxx.c       **** 			}
 276               		.loc 1 58 12 is_stmt 0 view .LVU74
 277 009e 21E0      		ldi r18,lo8(1)
 278               	.LVL14:
 279               	.L1:
  58:dhtxx.c       **** 			}
 280               		.loc 1 58 12 view .LVU75
 281               	.LBE55:
 282               	.LBE64:
 138:dhtxx.c       **** 	}
 139:dhtxx.c       **** 
 140:dhtxx.c       **** 	//Checksum calculation
 141:dhtxx.c       **** 	for ( i = 0; i < 4; i++ )
 142:dhtxx.c       **** 		cs += data[i];
 143:dhtxx.c       **** 	if ( cs != data[4] )
 144:dhtxx.c       **** 		return DHTXX_ERROR_CHECKSUM;
 145:dhtxx.c       **** 
 146:dhtxx.c       **** 	//Output values
 147:dhtxx.c       **** 	if ( dev == DHTXX_DHT22 ) //DHT22
 148:dhtxx.c       **** 	{
 149:dhtxx.c       **** 		//Will return humidity*10 and temperature*10
 150:dhtxx.c       **** 		*humidity = data[0] << 8 | data[1];
 151:dhtxx.c       **** 		*temperature = data[2] << 8 | data[3];
 152:dhtxx.c       **** 	}
 153:dhtxx.c       **** 	else //DHT11
 154:dhtxx.c       **** 	{
 155:dhtxx.c       **** 		*humidity = data[0] * 10;
 156:dhtxx.c       **** 		*temperature = data[2] * 10;
 157:dhtxx.c       **** 	}
 158:dhtxx.c       **** 
 159:dhtxx.c       **** 	return DHTXX_ERROR_OK;
 160:dhtxx.c       **** }
 283               		.loc 1 160 1 view .LVU76
 284 00a0 822F      		mov r24,r18
 285               	/* epilogue start */
 286 00a2 0F90      		pop __tmp_reg__
 287 00a4 0F90      		pop __tmp_reg__
 288 00a6 0F90      		pop __tmp_reg__
 289 00a8 0F90      		pop __tmp_reg__
 290 00aa 0F90      		pop __tmp_reg__
 291 00ac DF91      		pop r29
 292 00ae CF91      		pop r28
 293 00b0 1F91      		pop r17
 294               	.LVL15:
 295               		.loc 1 160 1 view .LVU77
 296 00b2 0F91      		pop r16
 297               	.LVL16:
 298               		.loc 1 160 1 view .LVU78
 299 00b4 FF90      		pop r15
 300 00b6 EF90      		pop r14
 301               	.LVL17:
 302               		.loc 1 160 1 view .LVU79
 303 00b8 DF90      		pop r13
 304 00ba CF90      		pop r12
 305 00bc BF90      		pop r11
 306 00be AF90      		pop r10
 307               	.LVL18:
 308               		.loc 1 160 1 view .LVU80
 309 00c0 9F90      		pop r9
 310 00c2 8F90      		pop r8
 311               	.LVL19:
 312               		.loc 1 160 1 view .LVU81
 313 00c4 7F90      		pop r7
 314 00c6 5F90      		pop r5
 315 00c8 4F90      		pop r4
 316               	.LVL20:
 317               		.loc 1 160 1 view .LVU82
 318 00ca 0895      		ret
 319               	.LVL21:
 320               	.L6:
 130:dhtxx.c       **** 	_delay_us( 40 );
 321               		.loc 1 130 1 is_stmt 1 view .LVU83
 131:dhtxx.c       **** 
 322               		.loc 1 131 2 view .LVU84
 323               	.LBB65:
 324               	.LBI65:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 325               		.loc 2 255 1 view .LVU85
 326               	.LBB66:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 327               		.loc 2 257 2 view .LVU86
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 328               		.loc 2 261 2 view .LVU87
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 329               		.loc 2 262 2 view .LVU88
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 330               		.loc 2 263 2 view .LVU89
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 331               		.loc 2 273 3 view .LVU90
 332               		.loc 2 276 2 view .LVU91
 333 00cc BDE0      		ldi r27,lo8(13)
 334 00ce BA95      	1:	dec r27
 335 00d0 01F4      		brne 1b
 336 00d2 0000      		nop
 337               	.LVL22:
 338               		.loc 2 276 2 is_stmt 0 view .LVU92
 339               	.LBE66:
 340               	.LBE65:
 134:dhtxx.c       **** 	{
 341               		.loc 1 134 2 is_stmt 1 view .LVU93
 134:dhtxx.c       **** 	{
 342               		.loc 1 134 2 is_stmt 0 view .LVU94
 343 00d4 AE01      		movw r20,r28
 344               	.LVL23:
 134:dhtxx.c       **** 	{
 345               		.loc 1 134 2 view .LVU95
 346 00d6 4F5F      		subi r20,-1
 347 00d8 5F4F      		sbci r21,-1
 348 00da 7C2E      		mov r7,r28
 349 00dc 26E0      		ldi r18,lo8(6)
 350 00de 720E      		add r7,r18
 351               	.LVL24:
 352               	.L16:
 136:dhtxx.c       **** 		if ( ec ) return ec;
 353               		.loc 1 136 3 is_stmt 1 view .LVU96
 354               	.LBB68:
 355               	.LBI46:
  34:dhtxx.c       **** {
 356               		.loc 1 34 16 view .LVU97
 357               	.LBB56:
  36:dhtxx.c       **** 	uint8_t data = 0;
 358               		.loc 1 36 2 view .LVU98
  36:dhtxx.c       **** 	uint8_t data = 0;
 359               		.loc 1 36 10 is_stmt 0 view .LVU99
 360 00e0 9FB7      		in r25,__SREG__
 361               	.LVL25:
  37:dhtxx.c       **** 	uint8_t timeoutcnt = 0;
 362               		.loc 1 37 2 is_stmt 1 view .LVU100
  38:dhtxx.c       **** 	uint8_t i = 0;
 363               		.loc 1 38 2 view .LVU101
  39:dhtxx.c       **** 
 364               		.loc 1 39 2 view .LVU102
  42:dhtxx.c       **** 
 365               		.loc 1 42 1 view .LVU103
 366               	/* #APP */
 367               	 ;  42 "dhtxx.c" 1
 368 00e2 F894      		cli
 369               	 ;  0 "" 2
  45:dhtxx.c       **** 	*port &= ~mask;
 370               		.loc 1 45 2 view .LVU104
  45:dhtxx.c       **** 	*port &= ~mask;
 371               		.loc 1 45 13 is_stmt 0 view .LVU105
 372               	/* #NOAPP */
 373 00e4 2081      		ld r18,Z
 374 00e6 2823      		and r18,r24
 375 00e8 2083      		st Z,r18
  46:dhtxx.c       **** 
 376               		.loc 1 46 2 is_stmt 1 view .LVU106
  46:dhtxx.c       **** 
 377               		.loc 1 46 8 is_stmt 0 view .LVU107
 378 00ea D401      		movw r26,r8
 379 00ec 2C91      		ld r18,X
 380 00ee 2823      		and r18,r24
 381 00f0 2C93      		st X,r18
  49:dhtxx.c       **** 	{
 382               		.loc 1 49 2 is_stmt 1 view .LVU108
 383               	.LVL26:
  37:dhtxx.c       **** 	uint8_t timeoutcnt = 0;
 384               		.loc 1 37 10 is_stmt 0 view .LVU109
 385 00f2 30E0      		ldi r19,0
  46:dhtxx.c       **** 
 386               		.loc 1 46 8 view .LVU110
 387 00f4 68E0      		ldi r22,lo8(8)
 388 00f6 70E0      		ldi r23,0
  49:dhtxx.c       **** 	{
 389               		.loc 1 49 10 view .LVU111
 390 00f8 A0E8      		ldi r26,lo8(-128)
 391 00fa DA2E      		mov r13,r26
 392               	.LVL27:
 393               	.L7:
  49:dhtxx.c       **** 	{
 394               		.loc 1 49 10 view .LVU112
 395               	.LBE56:
 396               	.LBE68:
 397               	.LBB69:
 398               	.LBB67:
 399               		.loc 2 276 2 view .LVU113
 400 00fc 2EE3      		ldi r18,lo8(62)
 401 00fe 00C0      		rjmp .L15
 402               	.LVL28:
 403               	.L9:
 404               		.loc 2 276 2 view .LVU114
 405               	.LBE67:
 406               	.LBE69:
 407               	.LBB70:
 408               	.LBB57:
  55:dhtxx.c       **** 			{
 409               		.loc 1 55 4 is_stmt 1 view .LVU115
  55:dhtxx.c       **** 			{
 410               		.loc 1 55 4 is_stmt 0 view .LVU116
 411 0100 2150      		subi r18,lo8(-(-1))
 412               	.LVL29:
  55:dhtxx.c       **** 			{
 413               		.loc 1 55 7 view .LVU117
 414 0102 01F4      		brne .+2
 415 0104 00C0      		rjmp .L26
 416               	.LVL30:
  60:dhtxx.c       **** 		}
 417               		.loc 1 60 4 is_stmt 1 view .LVU118
 418               	.LBB48:
 419               	.LBI48:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 420               		.loc 2 255 1 view .LVU119
 421               	.LBB49:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 422               		.loc 2 257 2 view .LVU120
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 423               		.loc 2 261 2 view .LVU121
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 424               		.loc 2 262 2 view .LVU122
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 425               		.loc 2 263 2 view .LVU123
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 426               		.loc 2 273 3 view .LVU124
 427               		.loc 2 276 2 view .LVU125
 428 0106 0000      		nop
 429               	.LVL31:
 430               	.L15:
 431               		.loc 2 276 2 is_stmt 0 view .LVU126
 432               	.LBE49:
 433               	.LBE48:
  53:dhtxx.c       **** 		{
 434               		.loc 1 53 14 view .LVU127
 435 0108 D201      		movw r26,r4
 436 010a CC90      		ld r12,X
  53:dhtxx.c       **** 		{
 437               		.loc 1 53 11 view .LVU128
 438 010c C022      		and r12,r16
  53:dhtxx.c       **** 		{
 439               		.loc 1 53 9 view .LVU129
 440 010e 01F0      		breq .L9
  63:dhtxx.c       **** 
 441               		.loc 1 63 3 is_stmt 1 view .LVU130
 442               	.LVL32:
 443               	.LBB50:
 444               	.LBI50:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 445               		.loc 2 255 1 view .LVU131
 446               	.LBB51:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 447               		.loc 2 257 2 view .LVU132
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 448               		.loc 2 261 2 view .LVU133
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 449               		.loc 2 262 2 view .LVU134
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 450               		.loc 2 263 2 view .LVU135
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 451               		.loc 2 273 3 view .LVU136
 452               		.loc 2 276 2 view .LVU137
 453 0110 BAE0      		ldi r27,lo8(10)
 454 0112 BA95      	1:	dec r27
 455 0114 01F4      		brne 1b
 456               	.LVL33:
 457               		.loc 2 276 2 is_stmt 0 view .LVU138
 458               	.LBE51:
 459               	.LBE50:
  65:dhtxx.c       **** 
 460               		.loc 1 65 3 is_stmt 1 view .LVU139
  65:dhtxx.c       **** 
 461               		.loc 1 65 8 is_stmt 0 view .LVU140
 462 0116 D201      		movw r26,r4
 463 0118 2C91      		ld r18,X
 464               	.LVL34:
  65:dhtxx.c       **** 
 465               		.loc 1 65 8 view .LVU141
 466 011a 2023      		and r18,r16
  65:dhtxx.c       **** 
 467               		.loc 1 65 6 view .LVU142
 468 011c 01F0      		breq .L10
  65:dhtxx.c       **** 
 469               		.loc 1 65 25 is_stmt 1 view .LVU143
  65:dhtxx.c       **** 
 470               		.loc 1 65 30 is_stmt 0 view .LVU144
 471 011e 3D29      		or r19,r13
 472               	.LVL35:
 473               	.L10:
  68:dhtxx.c       **** 		while ( *portin & mask )
 474               		.loc 1 68 3 is_stmt 1 view .LVU145
  69:dhtxx.c       **** 		{
 475               		.loc 1 69 3 view .LVU146
  69:dhtxx.c       **** 		{
 476               		.loc 1 69 9 is_stmt 0 view .LVU147
 477 0120 2EE3      		ldi r18,lo8(62)
 478 0122 C22E      		mov r12,r18
 479               	.LVL36:
 480               	.L11:
  69:dhtxx.c       **** 		{
 481               		.loc 1 69 11 view .LVU148
 482 0124 D201      		movw r26,r4
 483 0126 2C91      		ld r18,X
 484 0128 2023      		and r18,r16
  69:dhtxx.c       **** 		{
 485               		.loc 1 69 9 view .LVU149
 486 012a 01F4      		brne .L13
  49:dhtxx.c       **** 	{
 487               		.loc 1 49 22 view .LVU150
 488 012c D694      		lsr r13
 489               	.LVL37:
  49:dhtxx.c       **** 	{
 490               		.loc 1 49 22 view .LVU151
 491 012e 6150      		subi r22,1
 492 0130 7109      		sbc r23,__zero_reg__
  49:dhtxx.c       **** 	{
 493               		.loc 1 49 2 view .LVU152
 494 0132 01F4      		brne .L7
  80:dhtxx.c       **** 
 495               		.loc 1 80 2 is_stmt 1 view .LVU153
  80:dhtxx.c       **** 
 496               		.loc 1 80 8 is_stmt 0 view .LVU154
 497 0134 DA01      		movw r26,r20
 498 0136 3D93      		st X+,r19
 499 0138 AD01      		movw r20,r26
  82:dhtxx.c       **** 	return DHTXX_ERROR_OK;
 500               		.loc 1 82 1 is_stmt 1 view .LVU155
  82:dhtxx.c       **** 	return DHTXX_ERROR_OK;
 501               		.loc 1 82 6 is_stmt 0 view .LVU156
 502 013a 9FBF      		out __SREG__,r25
  83:dhtxx.c       **** }
 503               		.loc 1 83 2 is_stmt 1 view .LVU157
 504               	.LVL38:
  83:dhtxx.c       **** }
 505               		.loc 1 83 2 is_stmt 0 view .LVU158
 506               	.LBE57:
 507               	.LBE70:
 137:dhtxx.c       **** 	}
 508               		.loc 1 137 3 is_stmt 1 view .LVU159
 134:dhtxx.c       **** 	{
 509               		.loc 1 134 2 is_stmt 0 view .LVU160
 510 013c 7A12      		cpse r7,r26
 511 013e 00C0      		rjmp .L16
 512               	.LVL39:
 142:dhtxx.c       **** 	if ( cs != data[4] )
 513               		.loc 1 142 3 is_stmt 1 view .LVU161
 142:dhtxx.c       **** 	if ( cs != data[4] )
 514               		.loc 1 142 13 is_stmt 0 view .LVU162
 515 0140 8981      		ldd r24,Y+1
 516               	.LVL40:
 142:dhtxx.c       **** 	if ( cs != data[4] )
 517               		.loc 1 142 3 is_stmt 1 view .LVU163
 142:dhtxx.c       **** 	if ( cs != data[4] )
 518               		.loc 1 142 6 is_stmt 0 view .LVU164
 519 0142 9A81      		ldd r25,Y+2
 520 0144 980F      		add r25,r24
 521               	.LVL41:
 142:dhtxx.c       **** 	if ( cs != data[4] )
 522               		.loc 1 142 3 is_stmt 1 view .LVU165
 142:dhtxx.c       **** 	if ( cs != data[4] )
 523               		.loc 1 142 13 is_stmt 0 view .LVU166
 524 0146 EB81      		ldd r30,Y+3
 525               	.LVL42:
 142:dhtxx.c       **** 	if ( cs != data[4] )
 526               		.loc 1 142 6 view .LVU167
 527 0148 9E0F      		add r25,r30
 528               	.LVL43:
 142:dhtxx.c       **** 	if ( cs != data[4] )
 529               		.loc 1 142 3 is_stmt 1 view .LVU168
 143:dhtxx.c       **** 		return DHTXX_ERROR_CHECKSUM;
 530               		.loc 1 143 2 view .LVU169
 142:dhtxx.c       **** 	if ( cs != data[4] )
 531               		.loc 1 142 6 is_stmt 0 view .LVU170
 532 014a 3C81      		ldd r19,Y+4
 533 014c 930F      		add r25,r19
 534               	.LVL44:
 143:dhtxx.c       **** 		return DHTXX_ERROR_CHECKSUM;
 535               		.loc 1 143 5 view .LVU171
 536 014e 3D81      		ldd r19,Y+5
 537 0150 3913      		cpse r19,r25
 538 0152 00C0      		rjmp .L19
 147:dhtxx.c       **** 	{
 539               		.loc 1 147 2 is_stmt 1 view .LVU172
 540 0154 90E0      		ldi r25,0
 541               	.LVL45:
 147:dhtxx.c       **** 	{
 542               		.loc 1 147 2 is_stmt 0 view .LVU173
 543 0156 F0E0      		ldi r31,0
 147:dhtxx.c       **** 	{
 544               		.loc 1 147 5 view .LVU174
 545 0158 1130      		cpi r17,lo8(1)
 546 015a 01F4      		brne .L17
 547 015c 8B81      		ldd r24,Y+3
 548 015e 9C81      		ldd r25,Y+4
 549               	.LVL46:
 150:dhtxx.c       **** 		*temperature = data[2] << 8 | data[3];
 550               		.loc 1 150 3 is_stmt 1 view .LVU175
 150:dhtxx.c       **** 		*temperature = data[2] << 8 | data[3];
 551               		.loc 1 150 13 is_stmt 0 view .LVU176
 552 0160 4981      		ldd r20,Y+1
 553 0162 5A81      		ldd r21,Y+2
 554 0164 5427      		eor r21,r20
 555 0166 4527      		eor r20,r21
 556 0168 5427      		eor r21,r20
 557 016a F701      		movw r30,r14
 558               	.LVL47:
 150:dhtxx.c       **** 		*temperature = data[2] << 8 | data[3];
 559               		.loc 1 150 13 view .LVU177
 560 016c 5183      		std Z+1,r21
 561 016e 4083      		st Z,r20
 151:dhtxx.c       **** 	}
 562               		.loc 1 151 3 is_stmt 1 view .LVU178
 151:dhtxx.c       **** 	}
 563               		.loc 1 151 16 is_stmt 0 view .LVU179
 564 0170 9827      		eor r25,r24
 565 0172 8927      		eor r24,r25
 566 0174 9827      		eor r25,r24
 567 0176 D501      		movw r26,r10
 568 0178 8D93      		st X+,r24
 569 017a 9C93      		st X,r25
 570 017c 00C0      		rjmp .L1
 571               	.LVL48:
 572               	.L13:
 573               	.LBB71:
 574               	.LBB58:
  71:dhtxx.c       **** 			{
 575               		.loc 1 71 4 is_stmt 1 view .LVU180
  71:dhtxx.c       **** 			{
 576               		.loc 1 71 4 is_stmt 0 view .LVU181
 577 017e CA94      		dec r12
 578               	.LVL49:
  71:dhtxx.c       **** 			{
 579               		.loc 1 71 7 view .LVU182
 580 0180 CC20      		tst r12
 581 0182 01F4      		brne .+2
 582 0184 00C0      		rjmp .L26
 583               	.LVL50:
  76:dhtxx.c       **** 		}
 584               		.loc 1 76 4 is_stmt 1 view .LVU183
 585               	.LBB52:
 586               	.LBI52:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 587               		.loc 2 255 1 view .LVU184
 588               	.LBB53:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 589               		.loc 2 257 2 view .LVU185
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 590               		.loc 2 261 2 view .LVU186
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 591               		.loc 2 262 2 view .LVU187
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 592               		.loc 2 263 2 view .LVU188
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 593               		.loc 2 273 3 view .LVU189
 594               		.loc 2 276 2 view .LVU190
 595 0186 0000      		nop
 277:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 278:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #else
 279:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	uint8_t __ticks;
 280:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	double __tmp2 ;
 281:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 3e6) * __us;
 282:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp2 = ((F_CPU) / 4e6) * __us;
 283:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	if (__tmp < 1.0)
 284:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks = 1;
 285:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	else if (__tmp2 > 65535)
 286:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	{
 287:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		_delay_ms(__us / 1000.0);
 288:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	}
 289:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	else if (__tmp > 255)
 290:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	{
 291:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		uint16_t __ticks=(uint16_t)__tmp2;
 292:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		_delay_loop_2(__ticks);
 293:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		return;
 294:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	}
 295:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	else
 296:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 		__ticks = (uint8_t)__tmp;
 297:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	_delay_loop_1(__ticks);
 298:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #endif
 299:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** }
 596               		.loc 2 299 1 is_stmt 0 view .LVU191
 597 0188 00C0      		rjmp .L11
 598               	.LVL51:
 599               	.L17:
 600               		.loc 2 299 1 view .LVU192
 601               	.LBE53:
 602               	.LBE52:
 603               	.LBE58:
 604               	.LBE71:
 155:dhtxx.c       **** 		*temperature = data[2] * 10;
 605               		.loc 1 155 3 is_stmt 1 view .LVU193
 155:dhtxx.c       **** 		*temperature = data[2] * 10;
 606               		.loc 1 155 23 is_stmt 0 view .LVU194
 607 018a 6AE0      		ldi r22,lo8(10)
 608 018c 70E0      		ldi r23,0
 609 018e 00D0      		rcall __mulhi3
 610               	.LVL52:
 155:dhtxx.c       **** 		*temperature = data[2] * 10;
 611               		.loc 1 155 13 view .LVU195
 612 0190 D701      		movw r26,r14
 613 0192 8D93      		st X+,r24
 614 0194 9C93      		st X,r25
 156:dhtxx.c       **** 	}
 615               		.loc 1 156 3 is_stmt 1 view .LVU196
 156:dhtxx.c       **** 	}
 616               		.loc 1 156 26 is_stmt 0 view .LVU197
 617 0196 CF01      		movw r24,r30
 618 0198 6AE0      		ldi r22,lo8(10)
 619 019a 70E0      		ldi r23,0
 620 019c 00D0      		rcall __mulhi3
 156:dhtxx.c       **** 	}
 621               		.loc 1 156 16 view .LVU198
 622 019e F501      		movw r30,r10
 623               	.LVL53:
 156:dhtxx.c       **** 	}
 624               		.loc 1 156 16 view .LVU199
 625 01a0 9183      		std Z+1,r25
 626 01a2 8083      		st Z,r24
 627 01a4 00C0      		rjmp .L1
 628               	.LVL54:
 629               	.L19:
 144:dhtxx.c       **** 
 630               		.loc 1 144 10 view .LVU200
 631 01a6 22E0      		ldi r18,lo8(2)
 632 01a8 00C0      		rjmp .L1
 633               		.cfi_endproc
 634               	.LFE7:
 636               	.global	dhtxxconvert
 638               	dhtxxconvert:
 639               	.LVL55:
 640               	.LFB8:
 161:dhtxx.c       **** 
 162:dhtxx.c       **** uint8_t dhtxxconvert( unsigned char dev, volatile uint8_t *port, volatile uint8_t *direction, volat
 163:dhtxx.c       **** {
 641               		.loc 1 163 1 is_stmt 1 view -0
 642               		.cfi_startproc
 643               		.loc 1 163 1 is_stmt 0 view .LVU202
 644 01aa 0F93      		push r16
 645               	.LCFI17:
 646               		.cfi_def_cfa_offset 3
 647               		.cfi_offset 16, -2
 648 01ac CF93      		push r28
 649               	.LCFI18:
 650               		.cfi_def_cfa_offset 4
 651               		.cfi_offset 28, -3
 652 01ae DF93      		push r29
 653               	.LCFI19:
 654               		.cfi_def_cfa_offset 5
 655               		.cfi_offset 29, -4
 656               	/* prologue: function */
 657               	/* frame size = 0 */
 658               	/* stack size = 3 */
 659               	.L__stack_usage = 3
 660 01b0 DB01      		movw r26,r22
 661 01b2 FA01      		movw r30,r20
 662 01b4 E901      		movw r28,r18
 164:dhtxx.c       **** 	//Requests DHTxx device, but does not read the data (simply triggers conversion)
 165:dhtxx.c       **** 
 166:dhtxx.c       **** 	uint8_t sreg = SREG; //Status register backup
 663               		.loc 1 166 2 is_stmt 1 view .LVU203
 664               		.loc 1 166 10 is_stmt 0 view .LVU204
 665 01b6 3FB7      		in r19,__SREG__
 666               	.LVL56:
 167:dhtxx.c       **** 
 168:dhtxx.c       **** 	//Check if device type is correct
 169:dhtxx.c       **** 	if ( dev != DHTXX_DHT11 && dev != DHTXX_DHT22 ) return DHTXX_ERROR_OTHER;
 667               		.loc 1 169 2 is_stmt 1 view .LVU205
 668               		.loc 1 169 5 is_stmt 0 view .LVU206
 669 01b8 8230      		cpi r24,lo8(2)
 670 01ba 00F4      		brsh .L32
 170:dhtxx.c       **** 
 171:dhtxx.c       **** 	//Send start signal
 172:dhtxx.c       **** 	*direction &= ~mask;
 671               		.loc 1 172 2 is_stmt 1 view .LVU207
 672               		.loc 1 172 13 is_stmt 0 view .LVU208
 673 01bc 2081      		ld r18,Z
 674               	.LVL57:
 675               		.loc 1 172 13 view .LVU209
 676 01be 902F      		mov r25,r16
 677 01c0 9095      		com r25
 678 01c2 2923      		and r18,r25
 679 01c4 2083      		st Z,r18
 173:dhtxx.c       **** 	*port &= ~mask;
 680               		.loc 1 173 2 is_stmt 1 view .LVU210
 681               		.loc 1 173 8 is_stmt 0 view .LVU211
 682 01c6 2C91      		ld r18,X
 683 01c8 2923      		and r18,r25
 684 01ca 2C93      		st X,r18
 174:dhtxx.c       **** 	*direction |= mask;
 685               		.loc 1 174 2 is_stmt 1 view .LVU212
 686               		.loc 1 174 13 is_stmt 0 view .LVU213
 687 01cc 2081      		ld r18,Z
 688 01ce 202B      		or r18,r16
 689 01d0 2083      		st Z,r18
 175:dhtxx.c       **** 
 176:dhtxx.c       **** 	//Adjust start signal time for DHT11 and DHT22
 177:dhtxx.c       **** 	if ( dev == DHTXX_DHT22 )
 690               		.loc 1 177 2 is_stmt 1 view .LVU214
 691               		.loc 1 177 5 is_stmt 0 view .LVU215
 692 01d2 8130      		cpi r24,lo8(1)
 693 01d4 01F4      		brne .L29
 178:dhtxx.c       **** 		_delay_us( 500 );
 694               		.loc 1 178 3 is_stmt 1 view .LVU216
 695               	.LVL58:
 696               	.LBB72:
 697               	.LBI72:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 698               		.loc 2 255 1 view .LVU217
 699               	.LBB73:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 700               		.loc 2 257 2 view .LVU218
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 701               		.loc 2 261 2 view .LVU219
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 702               		.loc 2 262 2 view .LVU220
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 703               		.loc 2 263 2 view .LVU221
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 704               		.loc 2 273 3 view .LVU222
 276:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 705               		.loc 2 276 2 view .LVU223
 706 01d6 86EA      		ldi r24,lo8(-90)
 707 01d8 8A95      	1:	dec r24
 708 01da 01F4      		brne 1b
 709               	.LVL59:
 276:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 710               		.loc 2 276 2 is_stmt 0 view .LVU224
 711 01dc 00C0      		rjmp .
 712               	.LVL60:
 713               	.L30:
 276:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 714               		.loc 2 276 2 view .LVU225
 715               	.LBE73:
 716               	.LBE72:
 179:dhtxx.c       **** 	else
 180:dhtxx.c       **** 		_delay_ms( 18 );
 181:dhtxx.c       **** 
 182:dhtxx.c       **** 	//Turn pin into input, disable interrupts and wait for acknowledgement
 183:dhtxx.c       **** 	cli( );
 717               		.loc 1 183 1 is_stmt 1 view .LVU226
 718               	/* #APP */
 719               	 ;  183 "dhtxx.c" 1
 720 01de F894      		cli
 721               	 ;  0 "" 2
 184:dhtxx.c       **** 	*direction &= ~mask;
 722               		.loc 1 184 2 view .LVU227
 723               		.loc 1 184 13 is_stmt 0 view .LVU228
 724               	/* #NOAPP */
 725 01e0 8081      		ld r24,Z
 726 01e2 8923      		and r24,r25
 727 01e4 8083      		st Z,r24
 185:dhtxx.c       **** 	_delay_us( 30 + 40 );
 728               		.loc 1 185 2 is_stmt 1 view .LVU229
 729               	.LVL61:
 730               	.LBB74:
 731               	.LBI74:
 255:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 732               		.loc 2 255 1 view .LVU230
 733               	.LBB75:
 257:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 734               		.loc 2 257 2 view .LVU231
 261:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 735               		.loc 2 261 2 view .LVU232
 262:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e6) * __us;
 736               		.loc 2 262 2 view .LVU233
 263:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 737               		.loc 2 263 2 view .LVU234
 273:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 738               		.loc 2 273 3 view .LVU235
 276:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 739               		.loc 2 276 2 view .LVU236
 740 01e6 B7E1      		ldi r27,lo8(23)
 741 01e8 BA95      	1:	dec r27
 742 01ea 01F4      		brne 1b
 743 01ec 0000      		nop
 744               	.LVL62:
 276:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 745               		.loc 2 276 2 is_stmt 0 view .LVU237
 746               	.LBE75:
 747               	.LBE74:
 186:dhtxx.c       **** 
 187:dhtxx.c       **** 	//Communication check 1
 188:dhtxx.c       **** 	if ( *portin & mask )
 748               		.loc 1 188 2 is_stmt 1 view .LVU238
 749               		.loc 1 188 7 is_stmt 0 view .LVU239
 750 01ee 8881      		ld r24,Y
 751 01f0 8023      		and r24,r16
 189:dhtxx.c       **** 	{
 190:dhtxx.c       **** 		SREG = sreg;
 752               		.loc 1 190 7 view .LVU240
 753 01f2 3FBF      		out __SREG__,r19
 188:dhtxx.c       **** 	{
 754               		.loc 1 188 5 view .LVU241
 755 01f4 8111      		cpse r24,__zero_reg__
 756               		.loc 1 190 2 is_stmt 1 view .LVU242
 191:dhtxx.c       **** 		return DHTXX_ERROR_COMM;
 757               		.loc 1 191 3 view .LVU243
 758               		.loc 1 191 10 is_stmt 0 view .LVU244
 759 01f6 81E0      		ldi r24,lo8(1)
 760               	.LVL63:
 761               	.L27:
 762               	/* epilogue start */
 192:dhtxx.c       **** 	}
 193:dhtxx.c       **** 
 194:dhtxx.c       **** 	SREG = sreg;
 195:dhtxx.c       **** 	return DHTXX_ERROR_OK;
 196:dhtxx.c       **** }
 763               		.loc 1 196 1 view .LVU245
 764 01f8 DF91      		pop r29
 765 01fa CF91      		pop r28
 766               	.LVL64:
 767               		.loc 1 196 1 view .LVU246
 768 01fc 0F91      		pop r16
 769               	.LVL65:
 770               		.loc 1 196 1 view .LVU247
 771 01fe 0895      		ret
 772               	.LVL66:
 773               	.L29:
 180:dhtxx.c       **** 
 774               		.loc 1 180 3 is_stmt 1 view .LVU248
 775               	.LBB76:
 776               	.LBI76:
 166:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** {
 777               		.loc 2 166 1 view .LVU249
 778               	.LBB77:
 168:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** #if __HAS_DELAY_CYCLES && defined(__OPTIMIZE__) && \
 779               		.loc 2 168 2 view .LVU250
 172:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	extern void __builtin_avr_delay_cycles(unsigned long);
 780               		.loc 2 172 2 view .LVU251
 173:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	__tmp = ((F_CPU) / 1e3) * __ms;
 781               		.loc 2 173 2 view .LVU252
 174:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 782               		.loc 2 174 2 view .LVU253
 184:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 	#endif
 783               		.loc 2 184 3 view .LVU254
 187:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 784               		.loc 2 187 2 view .LVU255
 785 0200 A3E9      		ldi r26,lo8(4499)
 786 0202 B1E1      		ldi r27,hi8(4499)
 787 0204 1197      	1:	sbiw r26,1
 788 0206 01F4      		brne 1b
 789 0208 00C0      		rjmp .
 790 020a 0000      		nop
 210:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 791               		.loc 2 210 1 is_stmt 0 view .LVU256
 792 020c 00C0      		rjmp .L30
 793               	.LVL67:
 794               	.L32:
 210:/usr/local/Cellar/avr-gcc/9.1.0/avr/include/util/delay.h **** 
 795               		.loc 2 210 1 view .LVU257
 796               	.LBE77:
 797               	.LBE76:
 169:dhtxx.c       **** 
 798               		.loc 1 169 37 view .LVU258
 799 020e 83E0      		ldi r24,lo8(3)
 800               	.LVL68:
 169:dhtxx.c       **** 
 801               		.loc 1 169 37 view .LVU259
 802 0210 00C0      		rjmp .L27
 803               		.cfi_endproc
 804               	.LFE8:
 806               	.Letext0:
 807               		.file 3 "/usr/local/Cellar/avr-gcc/9.1.0/avr/include/stdint.h"
DEFINED SYMBOLS
                            *ABS*:0000000000000000 dhtxx.c
             dhtxx.s:2      *ABS*:000000000000003e __SP_H__
             dhtxx.s:3      *ABS*:000000000000003d __SP_L__
             dhtxx.s:4      *ABS*:000000000000003f __SREG__
             dhtxx.s:5      *ABS*:0000000000000000 __tmp_reg__
             dhtxx.s:6      *ABS*:0000000000000001 __zero_reg__
             dhtxx.s:12     .text:0000000000000000 dhtxxread
             dhtxx.s:638    .text:00000000000001aa dhtxxconvert

UNDEFINED SYMBOLS
__mulhi3
